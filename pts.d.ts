// Generated by dts-bundle v0.7.3



/**
    * Bound is a subclass of Group that represents a rectangular boundary.
    * It includes some convenient properties such as `x`, `y`, bottomRight`, `center`, and `size`.
    */
declare class Bound extends Group implements IPt {
        protected _center: Pt;
        protected _size: Pt;
        protected _topLeft: Pt;
        protected _bottomRight: Pt;
        protected _inited: boolean;
        /**
            * Create a Bound. This is similar to the Group constructor.
            * @param args a list of Pt as parameters
            */
        constructor(...args: Pt[]);
        /**
            * Create a Bound from a [ClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) object.
            * @param rect an object has top/left/bottom/right/width/height properties
            * @returns a Bound object
            */
        static fromBoundingRect(rect: ClientRect): Bound;
        static fromGroup(g: GroupLike): Bound;
        /**
            * Initiate the bound's properties.
            */
        protected init(): void;
        /**
            * Clone this bound and return a new one
            */
        clone(): Bound;
        /**
            * Recalculte size and center
            */
        protected _updateSize(): void;
        /**
            * Recalculate center
            */
        protected _updateCenter(): void;
        /**
            * Recalculate based on top-left position and size
            */
        protected _updatePosFromTop(): void;
        /**
            * Recalculate based on bottom-right position and size
            */
        protected _updatePosFromBottom(): void;
        /**
            * Recalculate based on center position and size
            */
        protected _updatePosFromCenter(): void;
        size: Pt;
        center: Pt;
        topLeft: Pt;
        bottomRight: Pt;
        width: number;
        height: number;
        depth: number;
        readonly x: number;
        readonly y: number;
        readonly z: number;
        readonly inited: boolean;
        /**
            * If the Group elements are changed, call this function to update the Bound's properties.
            * It's preferable to change the topLeft/bottomRight etc properties instead of changing the Group array directly.
            */
        update(): this;
}

declare interface PtsCanvasRenderingContext2D extends CanvasRenderingContext2D {
        webkitBackingStorePixelRatio?: number;
        mozBackingStorePixelRatio?: number;
        msBackingStorePixelRatio?: number;
        oBackingStorePixelRatio?: number;
        backingStorePixelRatio?: number;
}
/**
 * CanvasSpace is an implementation of the abstract class Space. It represents a space for HTML Canvas.
 * Learn more about the concept of Space in [this guide](..guide/Space-0500.html)
 */
declare class CanvasSpace extends MultiTouchSpace {
        protected _canvas: HTMLCanvasElement;
        protected _container: Element;
        protected _pixelScale: number;
        protected _autoResize: boolean;
        protected _bgcolor: string;
        protected _ctx: PtsCanvasRenderingContext2D;
        protected _offscreen: boolean;
        protected _offCanvas: HTMLCanvasElement;
        protected _offCtx: PtsCanvasRenderingContext2D;
        protected _initialResize: boolean;
        /**
         * Create a CanvasSpace which represents a HTML Canvas Space
         * @param elem Specify an element by its "id" attribute as string, or by the element object itself. An element can be an existing `<canvas>`, or a `<div>` container in which a new `<canvas>` will be created. If left empty, a `<div id="pt_container"><canvas id="pt" /></div>` will be added to DOM. Use css to customize its appearance if needed.
         * @param callback an optional callback `function(boundingBox, spaceElement)` to be called when canvas is appended and ready. Alternatively, a "ready" event will also be fired from the `<canvas>` element when it's appended, which can be traced with `spaceInstance.canvas.addEventListener("ready")`
         * @example `new CanvasSpace( "#myElementID" )`
         */
        constructor(elem: string | Element, callback?: Function);
        /**
         * Helper function to create a DOM element
         * @param elem element tag name
         * @param id element id attribute
         */
        protected _createElement(elem: string, id: any): HTMLElement;
        /**
         * Set up various options for CanvasSpace. The `opt` parameter is an object with the following fields. This is usually set during instantiation, eg `new CanvasSpace(...).setup( { opt } )`
         * @param opt an object with optional settings, as follows.
         * @param opt.bgcolor a hex or rgba string to set initial background color of the canvas, or use `false` or "transparent" to set a transparent background. You may also change it later with `clear()`
         * @param opt.resize a boolean to set whether `<canvas>` size should auto resize to match its container's size. You can also set it manually with `autoSize()`
         * @param opt.retina a boolean to set if device pixel scaling should be used. This may make drawings on retina displays look sharper but may reduce performance slightly. Default is `true`.
         * @param opt.offscreen a boolean to set if a duplicate canvas should be created for offscreen rendering. Default is `false`.
         * @example `space.setup({ bgcolor: "#f00", retina: true, resize: true })`
         */
        setup(opt: {
                bgcolor?: string;
                resize?: boolean;
                retina?: boolean;
                offscreen?: boolean;
        }): this;
        /**
         * Set whether the canvas element should resize when its container is resized.
         * @param auto a boolean value indicating if auto size is set
         */
        autoResize: boolean;
        /**
     * This overrides Space's `resize` function. It's used as a callback function for window's resize event and not usually called directly. You can keep track of resize events with `resize: (bound ,evt)` callback in your player objects (See `Space`'s `add()` function).
     * @param b a Bound object to resize to
     * @param evt Optionally pass a resize event
     */
        resize(b: Bound, evt?: Event): this;
        /**
         * Window resize handling
         * @param evt
         */
        protected _resizeHandler(evt: Event): void;
        /**
         * `pixelScale` property returns a number that let you determine if the screen is "retina" (when value >= 2)
         */
        readonly pixelScale: number;
        /**
         * Check if an offscreen canvas is created
         */
        readonly hasOffscreen: boolean;
        /**
         * Get the rendering context of offscreen canvas (if created via `setup()`)
         */
        readonly offscreenCtx: PtsCanvasRenderingContext2D;
        /**
         * Get the offscreen canvas element
         */
        readonly offscreenCanvas: HTMLCanvasElement;
        /**
         * Get a new `CanvasForm` for drawing
         * @see `CanvasForm`
         */
        getForm(): CanvasForm;
        /**
         * Get the html canvas element
         */
        readonly element: HTMLCanvasElement;
        /**
         * Get the parent element that contains the canvas element
         */
        readonly parent: Element;
        /**
            * A property to indicate if the Space is ready
            */
        readonly ready: boolean;
        /**
         * Get the rendering context of canvas
         */
        readonly ctx: PtsCanvasRenderingContext2D;
        /**
         * Clear the canvas with its background color. Overrides Space's `clear` function.
         * @param bg Optionally specify a custom background color in hex or rgba string, or "transparent". If not defined, it will use its `bgcolor` property as background color to clear the canvas.
         */
        clear(bg?: string): this;
        /**
         * Similiar to `clear()` but clear the offscreen canvas instead
         * @param bg Optionally specify a custom background color in hex or rgba string, or "transparent". If not defined, it will use its `bgcolor` property as background color to clear the canvas.
         */
        clearOffscreen(bg?: string): this;
        /**
         * Main animation function. Call `Space.playItems`.
         * @param time current time
         */
        protected playItems(time: number): void;
}
/**
 * CanvasForm is an implementation of abstract class VisualForm. It provide methods to express Pts on CanvasSpace.
 * You may extend CanvasForm to implement your own expressions for CanvasSpace.
 */
declare class CanvasForm extends VisualForm {
        protected _space: CanvasSpace;
        protected _ctx: CanvasRenderingContext2D;
        /**
         * store common styles so that they can be restored to canvas context when using multiple forms. See `reset()`.
         */
        protected _style: {
                fillStyle: string;
                strokeStyle: string;
                lineWidth: number;
                lineJoin: string;
                lineCap: string;
        };
        /**
         * Create a new CanvasForm. You may also use `space.getForm()` to get the default form.
         * @param space an instance of CanvasSpace
         */
        constructor(space: CanvasSpace);
        /**
         * get the CanvasSpace instance that this form is associated with
         */
        readonly space: CanvasSpace;
        /**
         * Toggle whether to draw on offscreen canvas (if offscreen is set in CanvasSpace)
         * @param off if `true`, draw on offscreen canvas instead of the visible canvas. Default is `true`
         * @param clear optionally provide a valid color string to fill a bg color. see CanvasSpace's `clearOffscreen` function.
         */
        useOffscreen(off?: boolean, clear?: boolean | string): this;
        /**
         * Render the offscreen canvas's content on the visible canvas
         * @param offset Optional offset on the top-left position when drawing on the visible canvas
         */
        renderOffscreen(offset?: PtLike): void;
        /**
         * Set current fill style. Provide a valid color string or `false` to specify no fill color.
         * @example `form.fill("#F90")`, `form.fill("rgba(0,0,0,.5")`, `form.fill(false)`
         * @param c fill color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle))
         */
        fill(c: string | boolean): this;
        /**
         * Set current stroke style. Provide a valid color string or `false` to specify no stroke color.
         * @example `form.stroke("#F90")`, `form.stroke("rgba(0,0,0,.5")`, `form.stroke(false)`, `form.stroke("#000", 0.5, 'round', 'square')`
         * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle))
         * @param width Optional value (can be floating point) to set line width
         * @param linejoin Optional string to set line joint style. Can be "miter", "bevel", or "round".
         * @param linecap Optional string to set line cap style. Can be "butt", "round", or "square".
         */
        stroke(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
         * Set the current font
         * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties
         * @param weight Optional font-weight string such as "bold"
         * @param style Optional font-style string such as "italic"
         * @param lineHeight Optional line-height number suchas 1.5
         * @param family Optional font-family such as "Helvetica, sans-serif"
         * @example `form.font( myFont )`, `form.font(14, "bold")`
         */
        font(sizeOrFont: number | Font, weight?: string, style?: string, lineHeight?: number, family?: string): this;
        /**
         * Reset the rendering context's common styles to this form's styles. This supports using multiple forms on the same canvas context.
         */
        reset(): this;
        protected _paint(): void;
        /**
         * Draws a point
         * @param p a Pt object
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         * @example `form.point( p )`, `form.point( p, 10, "circle" )`
         */
        point(p: PtLike, radius?: number, shape?: string): this;
        /**
         * A static function to draw a circle
         * @param ctx canvas rendering context
         * @param pt center position of the circle
         * @param radius radius of the circle
         */
        static circle(ctx: CanvasRenderingContext2D, pt: PtLike, radius?: number): void;
        /**
         * Draw a circle
         * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]
         * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)
         */
        circle(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw an arc.
         * @param ctx canvas rendering context
         * @param pt center position
         * @param radius radius of the arc circle
         * @param startAngle start angle of the arc
         * @param endAngle end angle of the arc
         * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
         */
        static arc(ctx: CanvasRenderingContext2D, pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): void;
        /**
         * Draw an arc.
         * @param pt center position
         * @param radius radius of the arc circle
         * @param startAngle start angle of the arc
         * @param endAngle end angle of the arc
         * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
         */
        arc(pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): this;
        /**
         * A static function to draw a square
         * @param ctx canvas rendering context
         * @param pt center position of the square
         * @param halfsize half size of the square
         */
        static square(ctx: CanvasRenderingContext2D, pt: PtLike, halfsize: number): void;
        /**
            * Draw a square, given a center and its half-size
            * @param pt center Pt
            * @param halfsize half-size
            */
        square(pt: PtLike, halfsize: number): this;
        /**
         * A static function to draw a line
         * @param ctx canvas rendering context
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        static line(ctx: CanvasRenderingContext2D, pts: GroupLike | number[][]): void;
        /**
         * Draw a line or polyline
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        line(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw polygon
         * @param ctx canvas rendering context
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        static polygon(ctx: CanvasRenderingContext2D, pts: GroupLike | number[][]): void;
        /**
         * Draw a polygon
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        polygon(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw a rectangle
         * @param ctx canvas rendering context
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        static rect(ctx: CanvasRenderingContext2D, pts: GroupLike | number[][]): void;
        /**
         * Draw a rectangle
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        rect(pts: number[][] | Pt[]): this;
        /**
         * A static function to draw text
         * @param ctx canvas rendering context
         * @param `pt` a Point object to specify the anchor point
         * @param `txt` a string of text to draw
         * @param `maxWidth` specify a maximum width per line
         */
        static text(ctx: CanvasRenderingContext2D, pt: PtLike, txt: string, maxWidth?: number): void;
        /**
         * Draw text on canvas
         * @param `pt` a Pt or numeric array to specify the anchor point
         * @param `txt` text
         * @param `maxWidth` specify a maximum width per line
         */
        text(pt: PtLike, txt: string, maxWidth?: number): this;
        /**
         * A convenient way to draw some text on canvas for logging or debugging. It'll be draw on the top-left of the canvas as an overlay.
         * @param txt text
         */
        log(txt: any): this;
}

declare type ColorType = "rgb" | "hsl" | "hsb" | "lab" | "lch" | "luv" | "xyz";
/**
    * Color is a subclass of Pt. You can think of a color as a point in a color space. The Color class provides support for many color spaces.
    */
declare class Color extends Pt {
        protected _mode: ColorType;
        /**
            * Value range for each color space
            */
        static ranges: {
                [name: string]: Group;
        };
        /**
            * Create a Color. Same as creating a Pt.
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        constructor(...args: any[]);
        /**
            * Create a Color object with defaults to 4 dimensions
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        static from(...args: any[]): Color;
        /**
            * Convert a rgb hex string like #FF0000 or #F00 to a Color object
            * @param hex a hex string, with optional '#' prefix
            */
        static fromHex(hex: string): Color;
        /**
            * Create RGB Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static rgb(...args: any[]): Color;
        /**
            * Create HSL Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static hsl(...args: any[]): Color;
        /**
            * Create HSB Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static hsb(...args: any[]): Color;
        /**
            * Create LAB Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static lab(...args: any[]): Color;
        /**
            * Create LCH Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static lch(...args: any[]): Color;
        /**
            * Create LUV Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static luv(...args: any[]): Color;
        /**
            * Create XYZ Color
            * @param args Pt-like parameters which can be a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties.
            */
        static xyz(...args: any[]): Color;
        /**
            * Get a Color object whose values are the maximum of its mode
            * @param mode a mode string such as "rgb" or "lab"
            * @example Color.maxValue("rgb") will return a rgb Color object with values (255,255,255)
            */
        static maxValues(mode: string): Pt;
        /**
            * Get a hex string such as "#FF0000". Same as `toString("hex")`
            */
        readonly hex: string;
        /**
            * Get a rgb string such as "rgb(255,0,0)". Same as `toString("rgb")`
            */
        readonly rgb: string;
        /**
            * Get a rgba string such as "rgb(255,0,0,0.5)". Same as `toString("rgba")`
            */
        readonly rgba: string;
        /**
            * Clone this Color
            */
        clone(): Color;
        /**
            * Convert this color from current color space to another color space
            * @param mode a ColorType string: "rgb" "hsl" "hsb" "lab" "lch" "luv" "xyz";
            * @param convert if `true`, convert this Color to the new color space specified in `mode`. Default is `false`, which only sets the color mode without converting color values.
            */
        toMode(mode: ColorType, convert?: boolean): this;
        /**
            * Get this Color's mode
            */
        readonly mode: ColorType;
        r: number;
        g: number;
        b: number;
        h: number;
        s: number;
        l: number;
        a: number;
        c: number;
        u: number;
        v: number;
        /**
            * Get alpha value
            */
        readonly alpha: number;
        /**
            * Normalize the color values to between 0 to 1, or revert it back to the min/max values in current color mode
            * @param toNorm a boolean value specifying whether to normalize (`true`) or revert (`false`)
            */
        normalize(toNorm?: boolean): Color;
        /**
            * Like `normalize()` but returns as a new Color
            * @param toNorm a boolean value specifying whether to normalize (`true`) or revert (`false`)
            * @returns new Color
            */
        $normalize(toNorm?: boolean): Color;
        /**
            * Convert this Color to a string. It can be used to get a hex or rgb string for use in rendering
            * @param format "hex", "rgb", "rgba", or "mode" which means using current color mode label. Default is "mode".
            */
        toString(format?: ("hex" | "rgb" | "rgba" | "mode")): string;
        /**
            * Convert RGB to HSL
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new HSL Color
            */
        static RGBtoHSL(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert HSL to RGB
            * @param hsl a HSL Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static HSLtoRGB(hsl: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert RGB to HSB
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new HSB Color
            */
        static RGBtoHSB(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert HSB to RGB
            * @param hsb a HSB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static HSBtoRGB(hsb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
        * Convert RGB to LAB
        * @param rgb a RGB Color
        * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
        * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
        * @returns a new LAB Color
        */
        static RGBtoLAB(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LAB to RGB
            * @param lab a LAB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static LABtoRGB(lab: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert RGB to LCH
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LCH Color
            */
        static RGBtoLCH(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LCH to RGB
            * @param lch a LCH Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static LCHtoRGB(lch: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert RGB to LUV
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LUV Color
            */
        static RGBtoLUV(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LUV to RGB
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static LUVtoRGB(luv: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert RGB to XYZ
            * @param rgb a RGB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new XYZ Color
            */
        static RGBtoXYZ(rgb: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert XYZ to RGB
            * @param xyz a XYZ Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new RGB Color
            */
        static XYZtoRGB(xyz: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert XYZ to LAB
            * @param xyz a XYZ Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LAB Color
            */
        static XYZtoLAB(xyz: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LAB to XYZ
            * @param lab a LAB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new XYZ Color
            */
        static LABtoXYZ(lab: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert XYZ to LUV
            * @param xyz a XYZ Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LUV Color
            */
        static XYZtoLUV(xyz: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LUV to XYZ
            * @param luv a LUV Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new XYZ Color
            */
        static LUVtoXYZ(luv: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LAB to LCH
            * @param lab a LAB Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LCH Color
            */
        static LABtoLCH(lab: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
        /**
            * Convert LCH to LAB
            * @param lch a LCH Color
            * @param normalizedInput a boolean specifying whether input color is normalized. Default is not normalized: `false`.
            * @param normalizedOutput a boolean specifying whether output color shoud be normalized. Default is not normalized: `false`.
            * @returns a new LAB Color
            */
        static LCHtoLAB(lch: Color, normalizedInput?: boolean, normalizedOutput?: boolean): Color;
}

/**
    * The `Create` class provides various convenient functions to create structures or shapes.
    */
declare class Create {
        /**
            * Create a set of random points inside a bounday
            * @param bound the rectangular boundary
            * @param count number of random points to create
            * @param dimensions number of dimensions in each point
            */
        static distributeRandom(bound: Bound, count: number, dimensions?: number): Group;
        /**
            * Create a set of points that distribute evenly on a line
            * @param line a Group representing a line
            * @param count number of points to create
            */
        static distributeLinear(line: GroupLike, count: number): Group;
        /**
            * Create an evenly distributed set of points (like a grid of points) inside a boundary.
            * @param bound the rectangular boundary
            * @param columns number of columns
            * @param rows number of rows
            * @param orientation a Pt or number array to specify where the point should be inside a cell. Default is [0.5, 0.5] which places the point in the middle.
            * @returns a Group of Pts
            */
        static gridPts(bound: Bound, columns: number, rows: number, orientation?: PtLike): Group;
        /**
            * Create a grid inside a boundary
            * @param bound the rectangular boundary
            * @param columns number of columns
            * @param rows number of rows
            * @returns an array of Groups, where each group represents a rectangular cell
            */
        static gridCells(bound: Bound, columns: number, rows: number): Group[];
        /**
            * Create a set of Pts around a circular path
            * @param center circle center
            * @param radius circle radius
            * @param count number of Pts to create
            */
        static radialPts(center: PtLike, radius: number, count: number): Group;
        /**
            * Given a group of Pts, return a new group of `Noise` Pts.
            * @param pts a Group or an array of Pts
            * @param dx small increment value in x dimension
            * @param dy small increment value in y dimension
            * @param rows Optional row count to generate 2D noise
            * @param columns Optional column count to generate 2D noise
            */
        static noisePts(pts: GroupLike, dx?: number, dy?: number, rows?: number, columns?: number): Group;
}
/**
    * A class to generate Perlin noise. Currently it implements a basic 2D noise. More to follow.
    * Based on https://gist.github.com/banksean/304522
    */
declare class Noise extends Pt {
        protected perm: number[];
        /**
            * Create a Noise Pt that's capable of generating noise
            * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        constructor(...args: any[]);
        /**
            * Set the initial noise values
            * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            * @example `noise.initNoise( 0.01, 0.1 )`
            */
        initNoise(...args: any[]): void;
        /**
            * Add a small increment to the noise values
            * @param x step in x dimension
            * @param y step in y dimension
            */
        step(x?: number, y?: number): void;
        /**
            * Specify a seed for this Noise
            * @param s seed value
            */
        seed(s: any): void;
        /**
            * Generate a 2D Perlin noise value
            */
        noise2D(): number;
}

/**
    * A type that represents the current context for an DOMForm
    */
declare type DOMFormContext = {
        group: Element;
        groupID: string;
        groupCount: number;
        currentID: string;
        currentClass?: string;
        style: object;
        font: string;
        fontSize: number;
        fontFamily: string;
};
/**
    * A Space for DOM elements
    */
declare class DOMSpace extends MultiTouchSpace {
        protected _canvas: HTMLElement | SVGElement;
        protected _container: Element;
        id: string;
        protected _autoResize: boolean;
        protected _bgcolor: string;
        protected _css: {};
        /**
         * Create a DOMSpace which represents a Space for DOM elements
         * @param elem Specify an element by its "id" attribute as string, or by the element object itself. Use css to customize its appearance if needed.
         * @param callback an optional callback `function(boundingBox, spaceElement)` to be called when canvas is appended and ready. Alternatively, a "ready" event will also be fired from the element when it's appended, which can be traced with `spaceInstance.canvas.addEventListener("ready")`
         * @example `new DOMSpace( "#myElementID" )`
         */
        constructor(elem: string | Element, callback?: Function);
        /**
         * Helper function to create a DOM element
         * @param elem element tag name
         * @param id element id attribute
         * @param appendTo Optional, if specified, the created element will be appended to this element
         */
        static createElement(elem: string, id: string, appendTo?: Element): Element;
        /**
         * Set up various options for DOMSpace. The `opt` parameter is an object with the following fields. This is usually set during instantiation, eg `new DOMSpace(...).setup( { opt } )`
         * @param opt an object with optional settings, as follows.
         * @param opt.bgcolor a hex or rgba string to set initial background color of the canvas, or use `false` or "transparent" to set a transparent background. You may also change it later with `clear()`
         * @param opt.resize a boolean to set whether `<canvas>` size should auto resize to match its container's size. You can also set it manually with `autoSize()`
         * @example `space.setup({ bgcolor: "#f00", resize: true })`
         */
        setup(opt: {
                bgcolor?: string;
                resize?: boolean;
        }): this;
        /**
            * Not implemented. See SVGSpace and HTMLSpace for implementation
            */
        getForm(): Form;
        /**
         * Set whether the canvas element should resize when its container is resized.
         * @param auto a boolean value indicating if auto size is set
         */
        autoResize: boolean;
        /**
         * This overrides Space's `resize` function. It's used as a callback function for window's resize event and not usually called directly. You can keep track of resize events with `resize: (bound ,evt)` callback in your player objects (See `Space`'s `add()` function).
         * @param b a Bound object to resize to
         * @param evt Optionally pass a resize event
         */
        resize(b: Bound, evt?: Event): this;
        /**
         * Window resize handling
         * @param evt
         */
        protected _resizeHandler(evt: Event): void;
        /**
         * Get this DOM element
         */
        readonly element: Element;
        /**
         * Get the parent DOM element that contains this DOM element
         */
        readonly parent: Element;
        /**
         * A property to indicate if the Space is ready
         */
        readonly ready: boolean;
        /**
         * Clear the element's contents, and ptionally set a new backgrounc color. Overrides Space's `clear` function.
         * @param bg Optionally specify a custom background color in hex or rgba string, or "transparent". If not defined, it will use its `bgcolor` property as background color to clear the canvas.
         */
        clear(bg?: string): this;
        /**
         * Set a background color on the container element
        @param bg background color as hex or rgba string
         */
        background: string;
        /**
         * Add or update a style definition, and optionally update that style in the Element
         * @param key style name
         * @param val style value
         * @param update a boolean to update the element's style immediately if set to `true`. Default is `false`.
         */
        style(key: string, val: string, update?: boolean): this;
        /**
         * Add of update a list of style definitions, and optionally update those styles in the Element
         * @param styles a key-value objects of style definitions
         * @param update a boolean to update the element's style immediately if set to `true`. Default is `false`.
         * @return this
         */
        styles(styles: object, update?: boolean): this;
        /**
         * A static helper function to add or update Element attributes
         * @param elem Element to update
         * @param data an object with key-value pairs
         * @returns this DOM element
         */
        static setAttr(elem: Element, data: object): Element;
        /**
         * A static helper function to compose an inline style string from a object of styles
         * @param elem Element to update
         * @param data an object with key-value pairs
         * @exmaple DOMSpace.getInlineStyles( {width: "100px", "font-size": "10px"} ); // returns "width: 100px; font-size: 10px"
         */
        static getInlineStyles(data: object): string;
}
/**
    * HTMLSpace. Note that this is currently experimental and may change in future.
    */
declare class HTMLSpace extends DOMSpace {
        /**
         * Get a new `HTMLForm` for drawing
         * @see `HTMLForm`
         */
        getForm(): Form;
        /**
            * A static function to add a DOM element inside a node. Usually you don't need to use this directly. See methods in `DOMForm` instead.
            * @param parent the parent element, or `null` to use current `<svg>` as parent.
            * @param name a string of element name,  such as `rect` or `circle`
            * @param id id attribute of the new element
            * @param autoClass add a class based on the id (from char 0 to index of "-"). Default is true.
            */
        static htmlElement(parent: Element, name: string, id?: string, autoClass?: boolean): HTMLElement;
        /**
         * Remove an item from this Space
         * @param item a player item with an auto-assigned `animateID` property
         */
        remove(player: IPlayer): this;
        /**
            * Remove all items from this Space
            */
        removeAll(): this;
}
/**
    * Form for HTMLSpace. Note that this is currently experimental and may change in future.
    */
declare class HTMLForm extends VisualForm {
        protected _ctx: DOMFormContext;
        static groupID: number;
        static domID: number;
        protected _space: HTMLSpace;
        protected _ready: boolean;
        constructor(space: HTMLSpace);
        readonly space: HTMLSpace;
        /**
            * Update a style in _ctx context or throw an Erorr if the style doesn't exist
            * @param k style key
            * @param v  style value
            * @param unit Optional unit like 'px' to append to value
            */
        protected styleTo(k: any, v: any, unit?: string): void;
        /**
         * Set current fill style. Provide a valid color string or `false` to specify no fill color.
         * @example `form.fill("#F90")`, `form.fill("rgba(0,0,0,.5")`, `form.fill(false)`
         * @param c fill color
         */
        fill(c: string | boolean): this;
        /**
         * Set current stroke style. Provide a valid color string or `false` to specify no stroke color.
         * @example `form.stroke("#F90")`, `form.stroke("rgba(0,0,0,.5")`, `form.stroke(false)`, `form.stroke("#000", 0.5, 'round', 'square')`
         * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle))
         * @param width Optional value (can be floating point) to set line width
         * @param linejoin not implemented in HTMLForm
         * @param linecap not implemented in HTMLForm
         */
        stroke(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
         * Set current text color style. Provide a valid color string.
         * @example `form.fill("#F90")`, `form.fill("rgba(0,0,0,.5")`, `form.fill(false)`
         * @param c fill color
         */
        fillText(c: string): this;
        /**
            * Add custom class to the created element
            * @param c custom class name or `false` to reset it
            * @example `form.fill("#f00").cls("myClass").rects(r)` `form.cls(false).circles(c)`
            */
        cls(c: string | boolean): this;
        /**
         * Set the current font
         * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties
         * @param weight Optional font-weight string such as "bold"
         * @param style Optional font-style string such as "italic"
         * @param lineHeight Optional line-height number suchas 1.5
         * @param family Optional font-family such as "Helvetica, sans-serif"
         * @example `form.font( myFont )`, `form.font(14, "bold")`
         */
        font(sizeOrFont: number | Font, weight?: string, style?: string, lineHeight?: number, family?: string): this;
        /**
         * Reset the context's common styles to this form's styles. This supports using multiple forms on the same canvas context.
         */
        reset(): this;
        /**
            * Set this form's group scope by an ID, and optionally define the group's parent element. A group scope keeps track of elements by their generated IDs, and updates their properties as needed. See also `scope()`.
            * @param group_id a string to use as prefix for the group's id. For example, group_id "hello" will create elements with id like "hello-1", "hello-2", etc
            * @param group Optional DOM element to define this group's parent element
            * @returns this form's context
            */
        updateScope(group_id: string, group?: Element): object;
        /**
            * Set the current group scope to an item added into space, in order to keep track of any point, circle, etc created within it. The item must have an `animateID` property, so that elements created within the item will have generated IDs like "item-{animateID}-{count}".
            * @param item a "player" item that's added to space (see `space.add(...)`) and has an `animateID` property
            * @returns this form's context
            */
        scope(item: IPlayer): object;
        /**
            * Get next available id in the current group
            * @returns an id string
            */
        nextID(): string;
        /**
            * A static function to generate an ID string based on a context object
            * @param ctx a context object for an HTMLForm
            */
        static getID(ctx: any): string;
        /**
            * A static function to generate an ID string for a scope, based on a "player" item in the Space
            * @param item a "player" item that's added to space (see `space.add(...)`) and has an `animateID` property
            */
        static scopeID(item: IPlayer): string;
        /**
            * A static function to help adding style object to an element. This put all styles into `style` attribute instead of individual attributes, so that the styles can be parsed by Adobe Illustrator.
            * @param elem A DOM element to add to
            * @param styles an object of style properties
            * @example `HTMLForm.style(elem, {fill: "#f90", stroke: false})`
            * @returns DOM element
            */
        static style(elem: Element, styles: object): Element;
        /**
        * A helper function to set top, left, width, height of DOM element
        * @param x left position
        * @param y top position
        * @param w width
        * @param h height
        */
        static rectStyle(ctx: DOMFormContext, pt: PtLike, size: PtLike): DOMFormContext;
        /**
         * Draws a point
         * @param ctx a context object of HTMLForm
         * @param pt a Pt object or numeric array
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         * @example `HTMLForm.point( p )`, `HTMLForm.point( p, 10, "circle" )`
         */
        static point(ctx: DOMFormContext, pt: PtLike, radius?: number, shape?: string): Element;
        /**
         * Draws a point
         * @param p a Pt object
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         * @example `form.point( p )`, `form.point( p, 10, "circle" )`
         */
        point(pt: PtLike, radius?: number, shape?: string): this;
        /**
         * A static function to draw a circle
         * @param ctx a context object of HTMLForm
         * @param pt center position of the circle
         * @param radius radius of the circle
         */
        static circle(ctx: DOMFormContext, pt: PtLike, radius?: number): Element;
        /**
         * Draw a circle
         * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]
         * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)
         */
        circle(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw a square
         * @param ctx a context object of HTMLForm
         * @param pt center position of the square
         * @param halfsize half size of the square
         */
        static square(ctx: DOMFormContext, pt: PtLike, halfsize: number): HTMLElement;
        /**
            * Draw a square, given a center and its half-size
            * @param pt center Pt
            * @param halfsize half-size
            */
        square(pt: PtLike, halfsize: number): this;
        /**
         * A static function to draw a rectangle
         * @param ctx a context object of HTMLForm
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        static rect(ctx: DOMFormContext, pts: GroupLike | number[][]): Element;
        /**
         * Draw a rectangle
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        rect(pts: number[][] | Pt[]): this;
        /**
         * A static function to draw text
         * @param ctx a context object of HTMLForm
         * @param `pt` a Point object to specify the anchor point
         * @param `txt` a string of text to draw
         * @param `maxWidth` specify a maximum width per line
         */
        static text(ctx: DOMFormContext, pt: PtLike, txt: string): Element;
        /**
         * Draw text on canvas
         * @param `pt` a Pt or numeric array to specify the anchor point
         * @param `txt` text
         * @param `maxWidth` specify a maximum width per line
         */
        text(pt: PtLike, txt: string): this;
        /**
         * A convenient way to draw some text on canvas for logging or debugging. It'll be draw on the top-left of the canvas as an overlay.
         * @param txt text
         */
        log(txt: any): this;
        /**
            * Arc is not implemented in HTMLForm
            */
        arc(pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): this;
        /**
            * Line is not implemented in HTMLForm
            */
        line(pts: GroupLike | number[][]): this;
        /**
            * Polygon is not implemented in HTMLForm
            * @param pts
            */
        polygon(pts: GroupLike | number[][]): this;
}

/**
 * Form is an abstract class that represents a form that's used in a Space for expressions.
 */
declare abstract class Form {
        protected _ready: boolean;
        /**
         * get whether the Form has received the Space's rendering context
         */
        readonly ready: boolean;
        /**
            * Check number of items in a Group against a required number
            * @param pts
            */
        static _checkSize(pts: GroupLike | number[][], required?: number): boolean;
}
/**
 * VisualForm is an abstract class that represents a form that can be used to express Pts visually.
 * For example, CanvasForm is an implementation of VisualForm that draws on CanvasSpace which represents a html canvas.
 */
declare abstract class VisualForm extends Form {
        protected _filled: boolean;
        filled: boolean;
        protected _stroked: boolean;
        stroked: boolean;
        protected _font: Font;
        readonly currentFont: Font;
        protected _multiple(groups: GroupLike[], shape: string, ...rest: any[]): this;
        /**
         * Abstract reset style
         */
        abstract reset(): this;
        /**
         * Set fill color (not implemented)
         */
        fill(c: string | boolean): this;
        /**
         * Set current fill style and without stroke.
         * @example `form.fillOnly("#F90")`, `form.fillOnly("rgba(0,0,0,.5")`
         * @param c fill color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle))
         */
        fillOnly(c: string | boolean): this;
        /**
         * Set stroke style (not implemented)
         */
        stroke(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
         * Set current stroke style and without fill.
         * @example `form.strokeOnly("#F90")`, `form.strokeOnly("#000", 0.5, 'round', 'square')`
         * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle)
         */
        strokeOnly(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
         * Abstract point drawing
         * @param p a Pt object
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         * @example `form.point( p )`, `form.point( p, 10, "circle" )`
         */
        abstract point(p: PtLike, radius: number, shape: string): this;
        /**
         * Draw multiple points at once
         * @param pts an array of Pt or an array of number arrays
         * @param radius radius of the point. Default is 5.
         * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
         */
        points(pts: GroupLike | number[][], radius: number, shape: string): this;
        /**
         * Abstract circle drawing
         * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]
         * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)
         */
        abstract circle(pts: GroupLike | number[][]): this;
        /**
         * Draw multiple circles at once
         * @param groups an array of Groups that defines multiple circles
         */
        circles(groups: GroupLike[]): this;
        /**
         * Draw multiple squares at once
         * @param groups an array of Groups that defines multiple circles
         */
        squares(groups: GroupLike[]): this;
        /**
         * Abstract arc drawing
         * @param pt center position
         * @param radius radius of the arc circle
         * @param startAngle start angle of the arc
         * @param endAngle end angle of the arc
         * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
         */
        abstract arc(pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): this;
        /**
         * Abstract a line or polyline drawing
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        abstract line(pts: GroupLike | number[][]): this;
        /**
         * Draw multiple lines at once
         * @param groups An array of Groups of Pts
         */
        lines(groups: GroupLike[]): this;
        /**
         * Abstract polygon drawing
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        abstract polygon(pts: GroupLike | number[][]): this;
        /**
         * Draw multiple polygons at once
         * @param groups An array of Groups of Pts
         */
        polygons(groups: GroupLike[]): this;
        /**
         * Abstract rectangle drawing
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        abstract rect(pts: number[][] | Pt[]): this;
        /**
         * Draw multiple rectangles at once
         * @param groups An array of Groups of Pts
         */
        rects(groups: GroupLike[]): this;
        /**
         * Abstract text rendering
         * @param `pt` a Pt or numeric array to specify the anchor point
         * @param `txt` text
         * @param `maxWidth` specify a maximum width per line
         */
        abstract text(pt: PtLike, txt: string, maxWidth?: number): this;
        /**
         * Abstract font setting
         * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties
         * @param weight Optional font-weight string such as "bold"
         * @param style Optional font-style string such as "italic"
         * @param lineHeight Optional line-height number suchas 1.5
         * @param family Optional font-family such as "Helvetica, sans-serif"
         * @see `Font` class
         * @example `form.font( myFont )`, `form.font(14, "bold")`
         */
        abstract font(sizeOrFont: number | Font, weight?: string, style?: string, lineHeight?: number, family?: string): this;
}
/**
 * Font class lets you create a specific font style with properties for its size and style
 */
declare class Font {
        size: number;
        lineHeight: number;
        face: string;
        style: string;
        weight: string;
        /**
         * Create a font style
         * @param size font size. Defaults is 12px.
         * @param face Optional font-family, use css-like string such as "Helvetica" or "Helvetica, sans-serif". Default is "sans-serif".
         * @param weight Optional font weight such as "bold". Default is "" (none).
         * @param style Optional font style such as "italic". Default is "" (none).
         * @param lineHeight Optional line height. Default is 1.5.
         * @example `new Font(12, "Frutiger, sans-serif", "bold", "underline", 1.5)`
         */
        constructor(size?: number, face?: string, weight?: string, style?: string, lineHeight?: number);
        /**
         * Get a string representing the font style, in css-like string such as "italic bold 12px/1.5 sans-serif"
         */
        readonly value: string;
        /**
         * Get a string representing the font style, in css-like string such as "italic bold 12px/1.5 sans-serif"
         */
        toString(): string;
}

/**
    * Vec provides static function for vector operations. It's not yet optimized but good enough to use.
    */
declare class Vec {
        /**
            * Add b to vector `a`
            * @returns vector `a`
            */
        static add(a: PtLike, b: PtLike | number): PtLike;
        /**
            * Subtract `b` from vector `a`
            * @returns vector `a`
            */
        static subtract(a: PtLike, b: PtLike | number): PtLike;
        /**
            * Multiply `b` with vector `a`
            * @returns vector `a`
            */
        static multiply(a: PtLike, b: PtLike | number): PtLike;
        /**
            * Divide `a` over `b`
            * @returns vector `a`
            */
        static divide(a: PtLike, b: PtLike | number): PtLike;
        /**
            * Dot product of `a` and `b`
            */
        static dot(a: PtLike, b: PtLike): number;
        /**
            * Cross product of `a` and `b` (3D only)
            */
        static cross(a: PtLike, b: PtLike): Pt;
        /**
            * Magnitude of `a`
            */
        static magnitude(a: PtLike): number;
        /**
            * Unit vector of `a`. If magnitude of `a` is already known, pass it in the second paramter to optimize calculation.
            */
        static unit(a: PtLike, magnitude?: number): PtLike;
        /**
            * Set `a` to its absolute value in each dimension
            * @returns vector `a`
            */
        static abs(a: PtLike): PtLike;
        /**
            * Set `a` to its floor value in each dimension
            * @returns vector `a`
            */
        static floor(a: PtLike): PtLike;
        /**
            * Set `a` to its ceiling value in each dimension
            * @returns vector `a`
            */
        static ceil(a: PtLike): PtLike;
        /**
            * Set `a` to its rounded value in each dimension
            * @returns vector `a`
            */
        static round(a: PtLike): PtLike;
        /**
            * Find the max value within a vector's dimensions
            * @returns an object with `value` and `index` that specifies the max value and its corresponding dimension.
            */
        static max(a: PtLike): {
                value;
                index;
        };
        /**
            * Find the min value within a vector's dimensions
            * @returns an object with `value` and `index` that specifies the min value and its corresponding dimension.
            */
        static min(a: PtLike): {
                value;
                index;
        };
        /**
            * Sum all the dimensions' values
            */
        static sum(a: PtLike): number;
        /**
            * Given a mapping function, update `a`'s value in each dimension
            * @returns vector `a`
            */
        static map(a: PtLike, fn: (n: number, index: number, arr) => number): PtLike;
}
/**
    * Mat provides static function for matrix operations. It's not yet optimized but good enough to use.
    */
declare class Mat {
        /**
            * Matrix additions. Matrices should have the same rows and columns.
            * @param a a group of Pt
            * @param b a scalar number, an array of numeric arrays, or a group of Pt
            * @returns a group with the same rows and columns as a and b
            */
        static add(a: GroupLike, b: GroupLike | number[][] | number): Group;
        /**
            * Matrix multiplication
            * @param a a Group of M Pts, each with K dimensions (M-rows, K-columns)
            * @param b a scalar number, an array of numeric arrays, or a Group of K Pts, each with N dimensions (K-rows, N-columns) -- or if transposed is true, then N Pts with K dimensions
            * @param transposed (Only applicable if it's not elementwise multiplication) If true, then a and b's columns should match (ie, each Pt should have the same dimensions). Default is `false`.
            * @param elementwise if true, then the multiplication is done element-wise. Default is `false`.
            * @returns If not elementwise, this will return a group with M Pt, each with N dimensions (M-rows, N-columns).
            */
        static multiply(a: GroupLike, b: GroupLike | number[][] | number, transposed?: boolean, elementwise?: boolean): Group;
        /**
            * Zip one slice of an array of Pt. Imagine the Pts are organized in rows, then this function will take the values in a specific column.
            * @param g a group of Pt
            * @param idx index to zip at
            * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.
            */
        static zipSlice(g: GroupLike | number[][], index: number, defaultValue?: number | boolean): Pt;
        /**
            * Zip a group of Pt. eg, [[1,2],[3,4],[5,6]] => [[1,3,5],[2,4,6]]
            * @param g a group of Pt
            * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.
            * @param useLongest If true, find the longest list of values in a Pt and use its length for zipping. Default is false, which uses the first item's length for zipping.
            */
        static zip(g: GroupLike | number[][], defaultValue?: number | boolean, useLongest?: boolean): Group;
        /**
            * Same as `zip` function
            */
        static transpose(g: GroupLike | number[][], defaultValue?: number | boolean, useLongest?: boolean): Group;
        /**
            * Transform a 2D point given a 2x3 or 3x3 matrix
            * @param pt a Pt to be transformed
            * @param m 2x3 or 3x3 matrix
            * @returns a new transformed Pt
            */
        static transform2D(pt: PtLike, m: GroupLike | number[][]): Pt;
        /**
            * Get a scale matrix for use in `transform2D`
            */
        static scale2DMatrix(x: number, y: number): GroupLike;
        /**
            * Get a rotate matrix for use in `transform2D`
            */
        static rotate2DMatrix(cosA: number, sinA: number): GroupLike;
        /**
            * Get a shear matrix for use in `transform2D`
            */
        static shear2DMatrix(tanX: number, tanY: number): GroupLike;
        /**
            * Get a translate matrix for use in `transform2D`
            */
        static translate2DMatrix(x: number, y: number): GroupLike;
        /**
            * Get a matrix to scale a point from an origin point. For use in `transform2D`
            */
        static scaleAt2DMatrix(sx: number, sy: number, at: PtLike): GroupLike;
        /**
            * Get a matrix to rotate a point from an origin point. For use in `transform2D`
            */
        static rotateAt2DMatrix(cosA: number, sinA: number, at: PtLike): GroupLike;
        /**
            * Get a matrix to shear a point from an origin point. For use in `transform2D`
            */
        static shearAt2DMatrix(tanX: number, tanY: number, at: PtLike): GroupLike;
        /**
            * Get a matrix to reflect a point along a line. For use in `transform2D`
            * @param p1 first end point to define the reflection line
            * @param p1 second end point to define the reflection line
            */
        static reflectAt2DMatrix(p1: PtLike, p2: PtLike): Pt[];
}

/**
    * Num class provides various helper functions for basic numeric operations
    */
declare class Num {
        /**
            * Check if two numbers are equal or almost equal within a threshold
            * @param a number a
            * @param b number b
            * @param threshold a threshold within which the two numbers are considered equal
            */
        static equals(a: number, b: number, threshold?: number): boolean;
        /**
            * Linear interpolation
            * @param a start value
            * @param b end value
            * @param t usually a value between 0 to 1
            */
        static lerp(a: number, b: number, t: number): number;
        /**
            * Clamp values between min and max
            * @param val value to clamp
            * @param min min value
            * @param max max value
            */
        static clamp(val: number, min: number, max: number): number;
        /**
            * Different from Num.clamp in that the value out-of-bound will be "looped back" to the other end.
            * @param val value to bound
            * @param min min value
            * @param max max value
            * @example `boundValue(361, 0, 360)` will return 1
            */
        static boundValue(val: number, min: number, max: number): number;
        /**
            * Check if a value is within
            * @param p
            * @param a
            * @param b
            */
        static within(p: number, a: number, b: number): boolean;
        /**
            * Get a random number within a range
            * @param a range value 1
            * @param b range value 2
            */
        static randomRange(a: number, b?: number): number;
        /**
            * Normalize a value within a range
            * @param n the value to normalize
            * @param a range value 1
            * @param b range value 1
            */
        static normalizeValue(n: number, a: number, b: number): number;
        /**
            * Sum a group of numeric arrays
            * @param pts an array of numeric arrays
            * @returns a array of sums
            */
        static sum(pts: GroupLike | number[][]): Pt;
        /**
            * Sum a group of numeric arrays
            * @param pts an array of numeric arrays
            * @returns a array of sums
            */
        static average(pts: GroupLike | number[][]): Pt;
        /**
            * Given a value between 0 to 1, returns a value that cycles between 0 -> 1 -> 0 using sine method.
            * @param t a value between 0 to 1
            * @return a value between 0 to 1
            */
        static cycle(t: number): number;
        /**
            * Map a value from one range to another
            * @param n a value in the first range
            * @param currMin lower bound of the first range
            * @param currMax upper bound of the first range
            * @param targetMin lower bound of the second range
            * @param targetMax upper bound of the second range
            * @returns a remapped value in the second range
            */
        static mapToRange(n: number, currA: any, currB: any, targetA: any, targetB: any): number;
}
/**
    * Geom class provides various helper functions for basic geometric operations
    */
declare class Geom {
        /**
            * Bound an angle between 0 to 360 degrees
            */
        static boundAngle(angle: number): number;
        /**
            * Bound a radian between 0 to 2-PI
            */
        static boundRadian(angle: number): number;
        /**
            * Convert an angle in degree to radian
            */
        static toRadian(angle: number): number;
        /**
            * Convert an angle in radian to degree
            */
        static toDegree(radian: number): number;
        /**
            * Get a bounding box for a set of Pts
            * @param pts a Group or an array of Pts
            * @return a Group of two Pts, representing the top-left and bottom-right corners.
            */
        static boundingBox(pts: GroupLike): Group;
        /**
            * Get a centroid (the average middle point) for a set of Pts
            * @param pts a Group or an array of Pts
            * @return a centroid Pt
            */
        static centroid(pts: GroupLike | number[][]): Pt;
        /**
            * Given an anchor Pt, rebase all Pts in this group either to or from this anchor base.
            * @param pts a Group or array of Pt
            * @param ptOrIndex an index for the Pt array, or an external Pt
            * @param direction "to" (subtract all Pt with this anchor base) or "from" (add all Pt from this anchor base)
            */
        static anchor(pts: GroupLike, ptOrIndex?: PtLike | number, direction?: ("to" | "from")): void;
        /**
            * Get an interpolated (or extrapolated) value between two Pts
            * @param a first Pt
            * @param b second Pt
            * @param t a value between 0 to 1 to interpolate, or any other value to extrapolate
            * @returns interpolated point as a new Pt
            */
        static interpolate(a: Pt | number[], b: Pt | number[], t?: number): Pt;
        /**
            * Find two Pt that are perpendicular to this Pt (2D)
            * @param axis a string such as "xy" (use Const.xy) or an array to specify index for two dimensions
            * @returns an array of two Pt that are perpendicular to this Pt
            */
        static perpendicular(pt: PtLike, axis?: string | number[]): Group;
        /**
            * Check if two Pts (vectors) are perpendicular to each other
            */
        static isPerpendicular(p1: PtLike, p2: PtLike): boolean;
        /**
            * Check if a Pt is within the rectangular boundary defined by two Pts
            * @param pt the Pt to check
            * @param boundPt1 boundary Pt 1
            * @param boundPt2 boundary Pt 2
            */
        static withinBound(pt: PtLike | number[], boundPt1: PtLike | number[], boundPt2: PtLike | number[]): boolean;
        /**
            * Scale a Pt or a Group of Pts
            * @param ps a Pt or a Group of Pts
            * @param scale scale value
            * @param anchor optional anchor point to scale from
            */
        static scale(ps: Pt | GroupLike, scale: number | number[] | PtLike, anchor?: PtLike): Geom;
        /**
            * Rotate a Pt or a Group of Pts in 2D space
            * @param ps a Pt or a Group of Pts
            * @param angle rotate angle
            * @param anchor optional anchor point to rotate from
            * @param axis optional axis such as "yz" to define a 2D plane of rotation
            */
        static rotate2D(ps: Pt | GroupLike, angle: number, anchor?: PtLike, axis?: string): Geom;
        /**
            * Shear a Pt or a Group of Pts in 2D space
            * @param ps a Pt or a Group of Pts
            * @param scale shearing value which can be a number or an array of 2 numbers
            * @param anchor optional anchor point to shear from
            * @param axis optional axis such as "yz" to define a 2D plane of shearing
            */
        static shear2D(ps: Pt | GroupLike, scale: number | number[] | PtLike, anchor?: PtLike, axis?: string): Geom;
        /**
            * Reflect a Pt or a Group of Pts along a 2D line
            * @param ps a Pt or a Group of Pts
            * @param line a Group of 2 Pts that defines a line for reflection
            * @param axis optional axis such as "yz" to define a 2D plane of reflection
            */
        static reflect2D(ps: Pt | GroupLike, line: GroupLike, axis?: string): Geom;
        /**
            * Generate a sine and cosine lookup table
            * @returns an object with 2 tables (array of 360 values) and 2 functions to get sin/cos given a radian parameter. { sinTable:Float64Array, cosTable:Float64Array, sin:(rad)=>number, cos:(rad)=>number }
            */
        static cosTable(): {
                table: Float64Array;
                cos: (rad: number) => number;
        };
        /**
            * Generate a sine and cosine lookup table
            * @returns an object with 2 tables (array of 360 values) and 2 functions to get sin/cos given a radian parameter. { sinTable:Float64Array, cosTable:Float64Array, sin:(rad)=>number, cos:(rad)=>number }
            */
        static sinTable(): {
                table: Float64Array;
                sin: (rad: number) => number;
        };
}
/**
    * Shaping provides various shaping/easing functions to interpolate a value non-linearly.
    */
declare class Shaping {
        /**
            * Linear mapping
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static linear(t: number, c?: number): number;
        /**
            * Quadratic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
         */
        static quadraticIn(t: number, c?: number): number;
        /**
            * Quadratic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
         */
        static quadraticOut(t: number, c?: number): number;
        /**
            * Quadratic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static quadraticInOut(t: number, c?: number): number;
        /**
            * Cubic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static cubicIn(t: number, c?: number): number;
        /**
            * Cubic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static cubicOut(t: number, c?: number): number;
        /**
            * Cubic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static cubicInOut(t: number, c?: number): number;
        /**
            * Exponential ease In, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p a value between 0 to 1 to control the curve. Default is 0.25.
            */
        static exponentialIn(t: number, c?: number, p?: number): number;
        /**
            * Exponential ease out, adapted from Golan Levin's [polynomial shapers](http://www.flong.com/texts/code/shapers_poly/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p a value between 0 to 1 to control the curve. Default is 0.25.
            */
        static exponentialOut(t: number, c?: number, p?: number): number;
        /**
            * Sinuous in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static sineIn(t: number, c?: number): number;
        /**
            * Sinuous out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static sineOut(t: number, c?: number): number;
        /**
            * Sinuous in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static sineInOut(t: number, c?: number): number;
        /**
            * A faster way to approximate cosine ease in-out using Blinn-Wyvill Approximation. Adapated from Golan Levin's [polynomial shaping](http://www.flong.com/texts/code/shapers_poly/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static cosineApprox(t: number, c?: number): number;
        /**
            * Circular in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static circularIn(t: number, c?: number): number;
        /**
            * Circular out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static circularOut(t: number, c?: number): number;
        /**
            * Circular in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static circularInOut(t: number, c?: number): number;
        /**
            * Elastic in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.
            */
        static elasticIn(t: number, c?: number, p?: number): number;
        /**
            * Elastic out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.7.
            */
        static elasticOut(t: number, c?: number, p?: number): number;
        /**
            * Elastic in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p elastic parmeter between 0 to 1. The lower the number, the more elastic it will be. Default is 0.6.
            */
        static elasticInOut(t: number, c?: number, p?: number): number;
        /**
            * Bounce in, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static bounceIn(t: number, c?: number): number;
        /**
            * Bounce out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static bounceOut(t: number, c?: number): number;
        /**
            * Bounce in-out, adapted from Robert Penner's [easing functions](http://robertpenner.com/easing/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            */
        static bounceInOut(t: number, c?: number): number;
        /**
            * Sigmoid curve changes its shape adapted from the input value, but always returns a value between 0 to 1.
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p the larger the value, the "steeper" the curve will be. Default is 10.
            */
        static sigmoid(t: number, c?: number, p?: number): number;
        /**
            * The Logistic Sigmoid is a useful curve. Adapted from Golan Levin's [shaping function](http://www.flong.com/texts/code/shapers_exp/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.7.
            */
        static logSigmoid(t: number, c?: number, p?: number): number;
        /**
            * An exponential seat curve. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p a parameter between 0 to 1 to control the steepness of the curve. Higher is steeper. Default is 0.5.
            */
        static seat(t: number, c?: number, p?: number): number;
        /**
            * Quadratic bezier curve. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_exp/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p1 a Pt object specifying the first control Pt, or a value specifying the control Pt's x position (its y position will default to 0.5). Default is `Pt(0.95, 0.95)
            */
        static quadraticBezier(t: number, c?: number, p?: number | PtLike): number;
        /**
            * Cubic bezier curve. This reuses the bezier functions in Curve class.
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p1` a Pt object specifying the first control Pt. Default is `Pt(0.1, 0.7).
            * @parma p2` a Pt object specifying the second control Pt. Default is `Pt(0.9, 0.2).
            */
        static cubicBezier(t: number, c?: number, p1?: PtLike, p2?: PtLike): number;
        /**
            * Give a Pt, draw a quadratic curve that will pass through that Pt as closely as possible. Adapted from Golan Levin's [shaping functions](http://www.flong.com/texts/code/shapers_poly/)
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p1` a Pt object specifying the Pt to pass through. Default is `Pt(0.2, 0.35)
            */
        static quadraticTarget(t: number, c?: number, p1?: PtLike): number;
        /**
            * Step function is a simple jump from 0 to 1 at a specific Pt in time
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma p usually a value between 0 to 1, which specify the Pt to "jump". Default is 0.5 which is in the middle.
            */
        static cliff(t: number, c?: number, p?: number): number;
        /**
            * Convert any shaping functions into a series of steps
            * @parma fn the original shaping function
            * @parma steps the number of steps
            * @parma t a value between 0 to 1
            * @parma c the value to shape, default is 1
            * @parma args optional paramters to pass to original function
            */
        static step(fn: Function, steps: number, t: number, c: number, ...args: any[]): any;
}

/**
    * Line class provides static functions to create and operate on lines. A line is usually represented as a Group of 2 Pts.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
declare class Line {
        /**
            * Create a line by "drawing" from an anchor point, given an angle and a magnitude
            * @param anchor an anchor Pt
            * @param angle an angle in radian
            * @param magnitude magnitude of the line
            * @return a Group of 2 Pts representing a line segement
            */
        static fromAngle(anchor: PtLike, angle: number, magnitude: number): Group;
        /**
            * Calculate the slope of a line
            * @param p1 line's first end point
            * @param p2 line's second end point
            */
        static slope(p1: PtLike | number[], p2: PtLike | number[]): number;
        /**
            * Calculate the slope and xy intercepts of a line
            * @param p1 line's first end point
            * @param p2 line's second end point
            * @returns an object with `slope`, `xi`, `yi` properties
            */
        static intercept(p1: PtLike | number[], p2: PtLike | number[]): {
                slope: number;
                xi: number;
                yi: number;
        };
        /**
            * Given a 2D path and a point, find whether the point is on left or right side of the line
            * @param line  a Group of at least 2 Pts
            * @param pt a Pt
            * @returns a negative value if on left and a positive value if on right. If collinear, then the return value is 0.
            */
        static sideOfPt2D(line: GroupLike, pt: PtLike): number;
        /**
            * Check if three Pts are collinear, ie, on the same straight path.
            * @param p1 first Pt
            * @param p2 second Pt
            * @param p3 third Pt
            * @param threshold a threshold where a smaller value means higher precision threshold for the straight line. Default is 0.01.
            */
        static collinear(p1: PtLike | number[], p2: PtLike | number[], p3: PtLike | number[], threshold?: number): boolean;
        /**
            * Get magnitude of a line segment
            * @param line a Group of at least 2 Pts
            */
        static magnitude(line: GroupLike): number;
        /**
            * Get squared magnitude of a line segment
            * @param line a Group of at least 2 Pts
            */
        static magnitudeSq(line: GroupLike): number;
        /**
            * Find a point on a line that is perpendicular (shortest distance) to a target point
            * @param pt a target Pt
            * @param ln a group of Pts that defines a line
            * @param asProjection if true, this returns the projection vector instead. Default is false.
            * @returns a Pt on the line that is perpendicular to the target Pt, or a projection vector if `asProjection` is true.
            */
        static perpendicularFromPt(line: GroupLike, pt: PtLike | number[], asProjection?: boolean): Pt;
        /**
            * Given a line and a point, find the shortest distance from the point to the line
            * @param line a Group of 2 Pts
            * @param pt a Pt
            * @see `Line.perpendicularFromPt`
            */
        static distanceFromPt(line: GroupLike, pt: PtLike | number[]): number;
        /**
            * Given two lines as rays (infinite lines), find their intersection point if any.
            * @param la a Group of 2 Pts representing a ray
            * @param lb a Group of 2 Pts representing a ray
            * @returns an intersection Pt or undefined if no intersection
            */
        static intersectRay2D(la: GroupLike, lb: GroupLike): Pt;
        /**
            * Given two line segemnts, find their intersection point if any.
            * @param la a Group of 2 Pts representing a line segment
            * @param lb a Group of 2 Pts representing a line segment
            * @returns an intersection Pt or undefined if no intersection
            */
        static intersectLine2D(la: GroupLike, lb: GroupLike): Pt;
        /**
            * Given a line segemnt and a ray (infinite line), find their intersection point if any.
            * @param line a Group of 2 Pts representing a line segment
            * @param ray a Group of 2 Pts representing a ray
            * @returns an intersection Pt or undefined if no intersection
            */
        static intersectLineWithRay2D(line: GroupLike, ray: GroupLike): Pt;
        /**
            * Given a line segemnt and a ray (infinite line), find its intersection point(s) with a polygon.
            * @param lineOrRay a Group of 2 Pts representing a line or ray
            * @param poly a Group of Pts representing a polygon
            * @param sourceIsRay a boolean value to treat the line as a ray (infinite line). Default is `false`.
            */
        static intersectPolygon2D(lineOrRay: GroupLike, poly: GroupLike[], sourceIsRay?: boolean): Group;
        /**
            * Get two intersection Pts of a ray with a 2D grid point
            * @param ray a ray specified by 2 Pts
            * @param gridPt a Pt on the grid
            * @returns a group of two intersecting Pts. The first one is horizontal intersection and the second one is vertical intersection.
            */
        static intersectGridWithRay2D(ray: GroupLike, gridPt: PtLike | number[]): Group;
        /**
            * Get two intersection Pts of a line segment with a 2D grid point
            * @param ray a ray specified by 2 Pts
            * @param gridPt a Pt on the grid
            * @returns a group of two intersecting Pts. The first one is horizontal intersection and the second one is vertical intersection.
            */
        static intersectGridWithLine2D(line: GroupLike, gridPt: PtLike | number[]): Group;
        /**
            * Quick way to check rectangle intersection.
            * For more optimized implementation, store the rectangle's sides separately (eg, `Rectangle.sides()`) and use `Polygon.intersect2D()`.
            * @param line a Group representing a line
            * @param rect a Group representing a rectangle
            */
        static intersectRect2D(line: GroupLike, rect: GroupLike): Group;
        /**
            * Get evenly distributed points on a line
            * @param line a Group representing a line
            * @param num number of points to get
            */
        static subpoints(line: GroupLike | number[][], num: number): Group;
        /**
            * Convert this line to a rectangle representation
            * @param line a Group representing a line
            */
        static toRect(line: GroupLike): Group;
}
/**
    * Rectangle class provides static functions to create and operate on rectangles. A rectangle is usually represented as a Group of 2 Pts, marking the top-left and bottom-right corners of the rectangle.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
declare class Rectangle {
        /**
            * Same as `Rectangle.fromTopLeft`
            */
        static from(topLeft: PtLike | number[], widthOrSize: number | PtLike, height?: number): Group;
        /**
            * Create a rectangle given a top-left position and a size
            * @param topLeft top-left point
            * @param widthOrSize width as a number, or a Pt that defines its size
            * @param height optional height as a number
            */
        static fromTopLeft(topLeft: PtLike | number[], widthOrSize: number | PtLike, height?: number): Group;
        /**
            * Create a rectangle given a center position and a size
            * @param topLeft top-left point
            * @param widthOrSize width as a number, or a Pt that defines its size
            * @param height optional height as a number
            */
        static fromCenter(center: PtLike | number[], widthOrSize: number | PtLike, height?: number): Group;
        /**
            * Convert this rectangle to a circle that fits within the rectangle
            * @returns a Group that represents a circle
            * @see `Circle`
            */
        static toCircle(pts: GroupLike): Group;
        /**
            * Create a square that either fits within or encloses a rectangle
            * @param pts a Group of 2 Pts representing a rectangle
            * @param enclose if `true`, the square will enclose the rectangle. Default is `false`, which will fit the square inside the rectangle.
            */
        static toSquare(pts: GroupLike, enclose?: boolean): Group;
        /**
            * Get the size of this rectangle as a Pt
            * @param pts a Group of 2 Pts representing a Rectangle
            */
        static size(pts: GroupLike): Pt;
        /**
            * Get the center of this rectangle
            * @param pts a Group of 2 Pts representing a Rectangle
            */
        static center(pts: GroupLike): Pt;
        /**
            * Get the 4 corners of this rectangle as a Group
            * @param rect a Group of 2 Pts representing a Rectangle
            */
        static corners(rect: GroupLike): Group;
        /**
            * Get the 4 sides of this rectangle as an array of 4 Groups
            * @param rect a Group of 2 Pts representing a Rectangle
            * @returns an array of 4 Groups, each of which represents a line segment
            */
        static sides(rect: GroupLike): Group[];
        /**
            * Same as `Rectangle.sides`
            */
        static lines(rect: GroupLike): Group[];
        /**
            * Given an array of rectangles, get a rectangle that bounds all of them
            * @param rects an array of Groups that represent rectangles
            * @returns the bounding rectangle as a Group
            */
        static boundingBox(rects: GroupLike[]): Group;
        /**
            * Convert this rectangle into a Group representing a polygon
            * @param rect a Group of 2 Pts representing a Rectangle
            */
        static polygon(rect: GroupLike): Group;
        /**
            * Subdivide this rectangle into 4 rectangles, one for each quadrant
            * @param rect a Group of 2 Pts representing a Rectangle
            * @returns an array of 4 Groups
            */
        static quadrants(rect: GroupLike, center?: PtLike): Group[];
        /**
            * Check if a point is within a rectangle
            * @param rect a Group of 2 Pts representing a Rectangle
            * @param pt the point to check
            */
        static withinBound(rect: GroupLike, pt: PtLike): boolean;
        /**
            * Check if a rectangle is within the bounds of another rectangle
            * @param rect1 a Group of 2 Pts representing a rectangle
            * @param rect2 a Group of 2 Pts representing a rectangle
            */
        static hasIntersectRect2D(rect1: GroupLike, rect2: GroupLike): boolean;
        /**
            * Quick way to check rectangle intersection.
            * For more optimized implementation, store the rectangle's sides separately (eg, `Rectangle.sides()`) and use `Polygon.intersect2D()`.
            * @param rect1 a Group of 2 Pts representing a rectangle
            * @param rect2 a Group of 2 Pts representing a rectangle
            */
        static intersectRect2D(rect1: GroupLike, rect2: GroupLike): Group;
}
/**
    * Circle class provides static functions to create and operate on circles. A circle is usually represented as a Group of 2 Pts, where the first Pt specifies the center, and the second Pt specifies the radius.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
declare class Circle {
        /**
            * Create a circle that either fits within or encloses a rectangle
            * @param pts a Group of 2 Pts representing a rectangle
            * @param enclose if `true`, the circle will enclose the rectangle. Default is `false`, which will fit the circle inside the rectangle.
            */
        static fromRect(pts: GroupLike, enclose?: boolean): Group;
        /**
            * Create a circle based on a center point and a radius
            * @param pt center point of circle
            * @param radius radius of circle
            */
        static fromCenter(pt: PtLike, radius: number): Group;
        /**
            * Check if a point is within a circle
            * @param pts a Group of 2 Pts representing a circle
            * @param pt the point to checks
            */
        static withinBound(pts: GroupLike, pt: PtLike): boolean;
        /**
            * Get the intersection points between a circle and a ray (infinite line)
            * @param pts a Group of 2 Pts representing a circle
            * @param ray a Group of 2 Pts representing a ray
            * @returns a Group of intersection points, or an empty Group if no intersection is found
            */
        static intersectRay2D(pts: GroupLike, ray: GroupLike): Group;
        /**
            * Get the intersection points between a circle and a line segment
            * @param pts a Group of 2 Pts representing a circle
            * @param ray a Group of 2 Pts representing a line
            * @returns a Group of intersection points, or an empty Group if no intersection is found
            */
        static intersectLine2D(pts: GroupLike, line: GroupLike): Group;
        /**
            * Get the intersection points between two circles
            * @param pts a Group of 2 Pts representing a circle
            * @param circle a Group of 2 Pts representing a circle
            * @returns a Group of intersection points, or an empty Group if no intersection is found
            */
        static intersectCircle2D(pts: GroupLike, circle: GroupLike): Group;
        /**
            * Quick way to check rectangle intersection with a circle.
            * For more optimized implementation, store the rectangle's sides separately (eg, `Rectangle.sides()`) and use `Polygon.intersect2D()`.
            * @param pts a Group of 2 Pts representing a circle
            * @param rect a Group of 2 Pts representing a rectangle
            * @returns a Group of intersection points, or an empty Group if no intersection is found
            */
        static intersectRect2D(pts: GroupLike, rect: GroupLike): Group;
        /**
            * Convert this cirlce to a rectangle that encloses this circle
            * @param pts a Group of 2 Pts representing a circle
            */
        static toRect(pts: GroupLike): Group;
        /**
            * Convert this cirlce to a rectangle that fits within this circle
            * @param pts a Group of 2 Pts representing a circle
            */
        static toInnerRect(pts: GroupLike): Group;
        /**
            * Convert this cirlce to a triangle that fits within this circle
            * @param pts a Group of 2 Pts representing a circle
            */
        static toInnerTriangle(pts: GroupLike): Group;
}
/**
    * Triangle class provides static functions to create and operate on trianges. A triange is usually represented as a Group of 3 Pts.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
declare class Triangle {
        /**
            * Create a triangle from a rectangle. The triangle will be isosceles, with the bottom of the rectangle as its base.
            * @param rect a Group of 2 Pts representing a rectangle
            */
        static fromRect(rect: GroupLike): Group;
        /**
            * Create a triangle that fits within a circle
            * @param circle a Group of 2 Pts representing a circle
            */
        static fromCircle(circle: GroupLike): Group;
        /**
            * Create an equilateral triangle based on a center point and a size
            * @param pt the center point
            * @param size size is the magnitude of lines from center to the triangle's vertices, like a "radius".
            */
        static fromCenter(pt: PtLike, size: number): Group;
        /**
            * Get the medial, which is an inner triangle formed by connecting the midpoints of this triangle's sides
            * @param pts a Group of Pts
            * @returns a Group representing a medial triangle
            */
        static medial(pts: GroupLike): Group;
        /**
            * Given a point of the triangle, the opposite side is the side which the point doesn't touch.
            * @param pts a Group of Pts
            * @param index a Pt on the triangle group
            * @returns a Group that represents a line of the opposite side
            */
        static oppositeSide(pts: GroupLike, index: number): Group;
        /**
            * Get a triangle's altitude, which is a line from a triangle's point to its opposite side, and perpendicular to its opposite side.
            * @param pts a Group of Pts
            * @param index a Pt on the triangle group
            * @returns a Group that represents the altitude line
            */
        static altitude(pts: GroupLike, index: number): Group;
        /**
            * Get orthocenter, which is the intersection point of a triangle's 3 altitudes (the 3 lines that are perpendicular to its 3 opposite sides).
            * @param pts a Group of Pts
            * @returns the orthocenter as a Pt
            */
        static orthocenter(pts: GroupLike): Pt;
        /**
            * Get incenter, which is the center point of its inner circle, and also the intersection point of its 3 angle bisector lines (each of which cuts one of the 3 angles in half).
            * @param pts a Group of Pts
            * @returns the incenter as a Pt
            */
        static incenter(pts: GroupLike): Pt;
        /**
            * Get an interior circle, which is the largest circle completed enclosed by this triangle
            * @param pts a Group of Pts
            * @param center Optional parameter if the incenter is already known. Otherwise, leave it empty and the incenter will be calculated
            */
        static incircle(pts: GroupLike, center?: Pt): Group;
        /**
            * Get circumcenter, which is the intersection point of its 3 perpendicular bisectors lines ( each of which divides a side in half and is perpendicular to the side)
            * @param pts a Group of Pts
            * @returns the circumcenter as a Pt
            */
        static circumcenter(pts: GroupLike): Pt;
        /**
            * Get circumcenter, which is the intersection point of its 3 perpendicular bisectors lines ( each of which divides a side in half and is perpendicular to the side)
            * @param pts a Group of Pts
            * @param center Optional parameter if the circumcenter is already known. Otherwise, leave it empty and the circumcenter will be calculated
            */
        static circumcircle(pts: GroupLike, center?: Pt): Group;
}
/**
    * Polygon class provides static functions to create and operate on polygons. A polygon is usually represented as a Group of 3 or more Pts.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
declare class Polygon {
        /**
            * Get the centroid of a polygon, which is the average of all its points.
            * @param pts a Group of Pts representing a polygon
            */
        static centroid(pts: GroupLike): Pt;
        /**
            * Get the line segments in this polygon
            * @param pts a Group of Pts
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            * @returns an array of Groups which has 2 Pts in each group
            */
        static lines(pts: GroupLike, closePath?: boolean): Group[];
        /**
            * Get a new polygon group that is derived from midpoints in this polygon
            * @param pts a Group of Pts
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            * @param t a value between 0 to 1 for interpolation. Default to 0.5 which will get the middle point.
            */
        static midpoints(pts: GroupLike, closePath?: boolean, t?: number): Group;
        /**
            * Given a Pt in the polygon group, the adjacent sides are the two sides which the Pt touches.
            * @param pts a group of Pts
            * @param index the target Pt
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            */
        static adjacentSides(pts: GroupLike, index: number, closePath?: boolean): Group[];
        /**
            * Get a bisector which is a line that split between two sides of a polygon equally.
            * @param pts a group of Pts
            * @param index the Pt in the polygon to bisect from
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            * @returns a bisector Pt that's a normalized unit vector
            */
        static bisector(pts: GroupLike, index: number): Pt;
        /**
            * Find the perimeter of this polygon, ie, the lengths of its sides.
            * @param pts a group of Pts
            * @param closePath a boolean to specify whether the polygon should be closed (ie, whether the final segment should be counted).
            * @returns an object with `total` length, and `segments` which is a Pt that stores each segment's length
            */
        static perimeter(pts: GroupLike, closePath?: boolean): {
                total: number;
                segments: Pt;
        };
        /**
            * Find the area of a *convex* polygon.
            * @param pts a group of Pts
            */
        static area(pts: GroupLike): any;
        /**
            * Get a convex hull of the point set using Melkman's algorithm
            * (Reference: http://geomalgorithms.com/a12-_hull-3.html)
            * @param pts a group of Pt
            * @param sorted a boolean value to indicate if the group is pre-sorted by x position. Default is false.
            * @returns a group of Pt that defines the convex hull polygon
            */
        static convexHull(pts: GroupLike, sorted?: boolean): Group;
        /**
            * Find intersection points of 2 polygons
            * @param poly a Group representing a polygon
            * @param linesOrRays an array of Groups representing lines
            * @param sourceIsRay a boolean value to treat the line as a ray (infinite line). Default is `false`.
            */
        static intersect2D(poly: GroupLike[], linesOrRays: GroupLike[], sourceIsRay?: boolean): Group[];
        /**
            * Given a point in the polygon as an origin, get an array of lines that connect all the remaining points to the origin point.
            * @param pts a Group representing a polygon
            * @param originIndex the origin point's index in the polygon
            */
        static network(pts: GroupLike, originIndex?: number): Group[];
        /**
            * Given a target Pt, find a Pt in a Group that's nearest to it.
            * @param pts a Group of Pt
            * @param pt Pt to check
            */
        static nearestPt(pts: GroupLike, pt: PtLike): Pt;
        /**
            * Get a bounding box for each polygon group, as well as a union bounding-box for all groups
            * @param polys an array of Groups, or an array of Pt arrays
            */
        static toRects(poly: GroupLike[]): GroupLike[];
}
/**
    * Curve class provides static functions to interpolate curves. A curve is usually represented as a Group of 3 control points.
    * You can use the static function as-is, or apply the `op` method in Group or Pt to many of these functions.
    * See [Op guide](../../guide/Op-0400.html) for details.
    */
declare class Curve {
        /**
            * Get a precalculated coefficients per step
            * @param steps number of steps
            */
        static getSteps(steps: number): Group;
        /**
            * Given an index for the starting position in a Pt group, get the control and/or end points of a curve segment
            * @param pts a group of Pt
            * @param index start index in `pts` array. Default is 0.
            * @param copyStart an optional boolean value to indicate if the start index should be used twice. Default is false.
            * @returns a group of 4 Pts
            */
        static controlPoints(pts: GroupLike, index?: number, copyStart?: boolean): Group;
        /**
            * Calulcate weighted sum to get the interpolated points
            * @param ctrls anchors
            * @param params parameters
            */
        static _calcPt(ctrls: GroupLike, params: PtLike): Pt;
        /**
            * Create a Catmull-Rom curve. Catmull-Rom is a kind of Cardinal curve with smooth-looking curve.
            * @param pts a group of anchor Pt
            * @param steps the number of line segments per curve. Defaults to 10 steps.
            * @returns a curve as a group of interpolated Pt
            */
        static catmullRom(pts: GroupLike, steps?: number): Group;
        /**
            * Interpolate to get a point on Catmull-Rom curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @return an interpolated Pt on the curve
            */
        static catmullRomStep(step: Pt, ctrls: GroupLike): Pt;
        /**
            * Create a Cardinal spline curve
            * @param pts a group of anchor Pt
            * @param steps the number of line segments per curve. Defaults to 10 steps.
            * @param tension optional value between 0 to 1 to specify a "tension". Default to 0.5 which is the tension for Catmull-Rom curve.
            * @returns a curve as a group of interpolated Pt
            */
        static cardinal(pts: GroupLike, steps?: number, tension?: number): Group;
        /**
            * Interpolate to get a point on Catmull-Rom curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @param tension optional value between 0 to 1 to specify a "tension". Default to 0.5 which is the tension for Catmull-Rom curve
            * @return an interpolated Pt on the curve
            */
        static cardinalStep(step: Pt, ctrls: GroupLike, tension?: number): Pt;
        /**
            * Create a Bezier curve. In a cubic bezier curve, the first and 4th anchors are end-points, and 2nd and 3rd anchors are control-points.
            * @param pts a group of anchor Pt
            * @param steps the number of line segments per curve. Defaults to 10 steps.
            * @returns a curve as a group of interpolated Pt
            */
        static bezier(pts: GroupLike, steps?: number): Group;
        /**
            * Interpolate to get a point on a cubic Bezier curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @return an interpolated Pt on the curve
            */
        static bezierStep(step: Pt, ctrls: GroupLike): Pt;
        /**
            * Create a B-spline curve
            * @param pts a group of anchor Pt
            * @param steps the number of line segments per curve. Defaults to 10 steps.
            * @param tension optional value between 0 to n to specify a "tension". Default is 1 which is the usual tension.
            * @returns a curve as a group of interpolated Pt
            */
        static bspline(pts: GroupLike, steps?: number, tension?: number): Group;
        /**
            * Interpolate to get a point on a B-spline curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @return an interpolated Pt on the curve
            */
        static bsplineStep(step: Pt, ctrls: GroupLike): Pt;
        /**
            * Interpolate to get a point on a B-spline curve
            * @param step the coefficients [t*t*t, t*t, t, 1]
            * @param ctrls a group of anchor Pts
            * @param tension optional value between 0 to n to specify a "tension". Default to 1 which is the usual tension.
            * @return an interpolated Pt on the curve
            */
        static bsplineTensionStep(step: Pt, ctrls: GroupLike, tension?: number): Pt;
}

declare interface IPt {
        x?: number;
        y?: number;
        z?: number;
        w?: number;
}
declare var PtBaseArray: Float32ArrayConstructor;
declare type GroupLike = Group | Pt[];
declare type PtLike = Pt | Float32Array | number[];
/**
    * Pt is a subclass of Float32Array with additional properties and functions to support vector and geometric calculations.
    * See [Pt guide](../../guide/Pt-0200.html) for details
    */
declare class Pt extends PtBaseArray implements IPt, Iterable<number> {
        protected _id: string;
        /**
            * Create a Pt. If no parameter is provided, this will instantiate a Pt with 2 dimensions [0, 0].
            *
            * Note that `new Pt(3)` will only instantiate Pt with length of 3 (ie, same as `new Float32Array(3)` ). If you need a Pt with 1 dimension of value 3, use `new Pt([3])`.
            * @example `new Pt()`, `new Pt(1,2,3,4,5)`, `new Pt([1,2])`, `new Pt({x:0, y:1})`, `new Pt(pt)`
            * @param args a list of numeric parameters, an array of numbers, or an object with {x,y,z,w} properties
            */
        constructor(...args: any[]);
        static make(dimensions: number, defaultValue?: number, randomize?: boolean): Pt;
        id: string;
        x: number;
        y: number;
        z: number;
        w: number;
        /**
            * Clone this Pt
            */
        clone(): Pt;
        /**
            * Check if another Pt is equal to this Pt, within a threshold
            * @param p another Pt to compare with
            * @param threshold a threshold value within which the two Pts are considered equal. Default is 0.000001.
            */
        equals(p: PtLike, threshold?: number): boolean;
        /**
            * Update the values of this Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        to(...args: any[]): this;
        /**
            * Like `to()` but returns a new Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $to(...args: any[]): Pt;
        /**
            * Update the values of this Pt to point at a specific angle
            * @param radian target angle in radian
            * @param magnitude Optional magnitude if known. If not provided, it'll calculate and use this Pt's magnitude.
            * @param anchorFromPt If `true`, translate to new position from current position. Default is `false` which update the position from origin (0,0);
            */
        toAngle(radian: number, magnitude?: number, anchorFromPt?: boolean): this;
        /**
            * Create an operation using this Pt, passing this Pt into a custom function's first parameter. See the [Op guide](../../guide/Op-0400.html) for details.
            * For example: `let myOp = pt.op( fn ); let result = myOp( [1,2,3] );`
            * @param fn any function that takes a Pt as its first parameter
            * @returns a resulting function that takes other parameters required in `fn`
            */
        op(fn: (p1: PtLike, ...rest: any[]) => any): (...rest: any[]) => any;
        /**
            * This combines a series of operations into an array. See `op()` for details.
            * For example: `let myOps = pt.ops([fn1, fn2, fn3]); let results = myOps.map( (op) => op([1,2,3]) );`
            * @param fns an array of functions for `op`
            * @returns an array of resulting functions
            */
        ops(fns: ((p1: PtLike, ...rest: any[]) => any)[]): ((...rest: any[]) => any)[];
        /**
            * Take specific dimensional values from this Pt and create a new Pt
            * @param axis a string such as "xy" (use Const.xy) or an array to specify index for two dimensions
            */
        $take(axis: string | number[]): Pt;
        /**
            * Concatenate this Pt with addition dimensional values and return as a new Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $concat(...args: any[]): Pt;
        /**
            * Add scalar or vector values to this Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        add(...args: any[]): this;
        /**
            * Like `add`, but returns result as a new Pt
            */
        $add(...args: any[]): Pt;
        /**
            * Subtract scalar or vector values from this Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        subtract(...args: any[]): this;
        /**
            * Like `subtract`, but returns result as a new Pt
            */
        $subtract(...args: any[]): Pt;
        /**
            * Multiply scalar or vector values (as element-wise) with this Pt.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        multiply(...args: any[]): this;
        /**
            * Like `multiply`, but returns result as a new Pt
            */
        $multiply(...args: any[]): Pt;
        /**
            * Divide this Pt over scalar or vector values (as element-wise)
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        divide(...args: any[]): this;
        /**
            * Like `divide`, but returns result as a new Pt
            */
        $divide(...args: any[]): Pt;
        /**
            * Get the sqaured distance (magnitude) of this Pt from origin
            */
        magnitudeSq(): number;
        /**
            * Get the distance (magnitude) of this Pt from origin
            */
        magnitude(): number;
        /**
            * Convert to a unit vector, which is a normalized vector whose magnitude equals 1.
            * @param magnitude Optional: if the magnitude is known, pass it as a parameter to avoid duplicate calculation.
            */
        unit(magnitude?: number): Pt;
        /**
            * Get a unit vector from this Pt
            */
        $unit(magnitude?: number): Pt;
        /**
            * Dot product of this Pt and another Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        dot(...args: any[]): number;
        /**
            * 3D Cross product of this Pt and another Pt. Return results as a new Pt.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $cross(...args: any[]): Pt;
        /**
            * Calculate vector projection of this Pt on another Pt. Returns result as a new Pt.
            * @param p a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $project(p: Pt): Pt;
        /**
            * Absolute values for all values in this pt
            */
        abs(): Pt;
        /**
            * Get a new Pt with absolute values of this Pt
            */
        $abs(): Pt;
        /**
            * Floor values for all values in this pt
            */
        floor(): Pt;
        /**
            * Get a new Pt with floor values of this Pt
            */
        $floor(): Pt;
        /**
            * Ceil values for all values in this pt
            */
        ceil(): Pt;
        /**
            * Get a new Pt with ceil values of this Pt
            */
        $ceil(): Pt;
        /**
            * Round values for all values in this pt
            */
        round(): Pt;
        /**
            * Get a new Pt with round values of this Pt
            */
        $round(): Pt;
        /**
            * Find the minimum value across all dimensions in this Pt
            * @returns an object with `value` and `index` which returns the minimum value and its dimensional index
            */
        minValue(): {
                value: number;
                index: number;
        };
        /**
            * Find the maximum value across all dimensions in this Pt
            * @returns an object with `value` and `index` which returns the maximum value and its dimensional index
            */
        maxValue(): {
                value: number;
                index: number;
        };
        /**
            * Get a new Pt that has the minimum dimensional values of this Pt and another Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $min(...args: any[]): Pt;
        /**
            * Get a new Pt that has the maximum dimensional values of this Pt and another Pt
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        $max(...args: any[]): Pt;
        /**
            * Get angle of this vector from origin
            * @param axis a string such as "xy" (use Const.xy) or an array to specify index for two dimensions
            */
        angle(axis?: string | number[]): number;
        /**
            * Get the angle between this and another Pt
            * @param p the other Pt
            * @param axis a string such as "xy" (use Const.xy) or an array to specify index for two dimensions
            */
        angleBetween(p: Pt, axis?: string | number[]): number;
        /**
            * Scale this Pt from origin or from an anchor point
            * @param scale scale ratio
            * @param anchor optional anchor point to scale from
            */
        scale(scale: number | number[] | PtLike, anchor?: PtLike): this;
        /**
            * Rotate this Pt from origin or from an anchor point in 2D
            * @param angle rotate angle
            * @param anchor optional anchor point to scale from
            * @param axis optional string such as "yz" to specify a 2D plane
            */
        rotate2D(angle: number, anchor?: PtLike, axis?: string): this;
        /**
            * Shear this Pt from origin or from an anchor point in 2D
            * @param shear shearing value which can be a number or an array of 2 numbers
            * @param anchor optional anchor point to scale from
            * @param axis optional string such as "yz" to specify a 2D plane
            */
        shear2D(scale: number | number[] | PtLike, anchor?: PtLike, axis?: string): this;
        /**
            * Reflect this Pt along a 2D line
            * @param line a Group of 2 Pts that defines a line for reflection
            * @param axis optional axis such as "yz" to define a 2D plane of reflection
            */
        reflect2D(line: GroupLike, axis?: string): this;
        /**
            * A string representation of this Pt: "Pt(1, 2, 3)"
            */
        toString(): string;
        /**
            * Convert this Pt to a javascript Array
            */
        toArray(): number[];
}
/**
    * A Group is a subclass of Array. It should onnly contain Pt instances. You can think of it as an array of arrays (Float32Arrays to be specific).
    * See [Group guide](../../guide/Group-0300.html) for details
    */
declare class Group extends Array<Pt> {
        protected _id: string;
        constructor(...args: Pt[]);
        id: string;
        /** The first Pt in this group */
        readonly p1: Pt;
        /** The second Pt in this group */
        readonly p2: Pt;
        /** The third Pt in this group */
        readonly p3: Pt;
        /** The forth Pt in this group */
        readonly p4: Pt;
        /** The last Pt in this group */
        readonly q1: Pt;
        /** The second-last Pt in this group */
        readonly q2: Pt;
        /** The third-last Pt in this group */
        readonly q3: Pt;
        /** The forth-last Pt in this group */
        readonly q4: Pt;
        /**
            * Depp clone this group and its Pts
            */
        clone(): Group;
        /**
            * Convert an array of numeric arrays into a Group of Pts
            * @param list an array of numeric arrays
            * @example `Group.fromArray( [[1,2], [3,4], [5,6]] )`
            */
        static fromArray(list: PtLike[]): Group;
        /**
            * Convert an array of Pts into a Group.
            * @param list an array of Pts
            */
        static fromPtArray(list: GroupLike): Group;
        /**
            * Split this Group into an array of sub-groups
            * @param chunkSize number of items per sub-group
            * @param stride forward-steps after each sub-group
            * @param loopBack if `true`, always go through the array till the end and loop back to the beginning to complete the segments if needed
            */
        split(chunkSize: number, stride?: number, loopBack?: boolean): Group[];
        /**
            * Insert a Pt into this group
            * @param pts Another group of Pts
            * @param index the index position to insert into
            */
        insert(pts: GroupLike, index?: number): this;
        /**
            * Like Array's splice function, with support for negative index and a friendlier name.
            * @param index start index, which can be negative (where -1 is at index 0, -2 at index 1, etc)
            * @param count number of items to remove
            * @returns The items that are removed.
            */
        remove(index?: number, count?: number): Group;
        /**
            * Split this group into an array of sub-group segments
            * @param pts_per_segment number of Pts in each segment
            * @param stride forward-step to take
            * @param loopBack if `true`, always go through the array till the end and loop back to the beginning to complete the segments if needed
            */
        segments(pts_per_segment?: number, stride?: number, loopBack?: boolean): Group[];
        /**
            * Get all the line segments (ie, edges in a graph) of this group
            */
        lines(): Group[];
        /**
            * Find the centroid of this group's Pts, which is the average middle point.
            */
        centroid(): Pt;
        /**
            * Find the rectangular bounding box of this group's Pts.
            * @returns a Group of 2 Pts representing the top-left and bottom-right of the rectangle
            */
        boundingBox(): Group;
        /**
            * Anchor all the Pts in this Group using a target Pt as origin. (ie, subtract all Pt with the target anchor to get a relative position). All the Pts' values will be updated.
            * @param ptOrIndex a Pt, or a numeric index to target a specific Pt in this Group
            */
        anchorTo(ptOrIndex?: PtLike | number): void;
        /**
            * Anchor all the Pts in this Group by its absolute position from a target Pt. (ie, add all Pt with the target anchor to get an absolute position).  All the Pts' values will be updated.
            * @param ptOrIndex a Pt, or a numeric index to target a specific Pt in this Group
            */
        anchorFrom(ptOrIndex?: PtLike | number): void;
        /**
            * Create an operation using this Group, passing this Group into a custom function's first parameter.  See the [Op guide](../../guide/Op-0400.html) for details.
            * For example: `let myOp = group.op( fn ); let result = myOp( [1,2,3] );`
            * @param fn any function that takes a Group as its first parameter
            * @returns a resulting function that takes other parameters required in `fn`
            */
        op(fn: (g1: GroupLike, ...rest: any[]) => any): (...rest: any[]) => any;
        /**
            * This combines a series of operations into an array. See `op()` for details.
            * For example: `let myOps = pt.ops([fn1, fn2, fn3]); let results = myOps.map( (op) => op([1,2,3]) );`
            * @param fns an array of functions for `op`
            * @returns an array of resulting functions
            */
        ops(fns: ((g1: GroupLike, ...rest: any[]) => any)[]): ((...rest: any[]) => any)[];
        /**
            * Get an interpolated point on the line segments defined by this Group
            * @param t a value between 0 to 1 usually
            */
        interpolate(t: number): Pt;
        /**
            * Move every Pt's position by a specific amount. Same as `add`.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        moveBy(...args: any[]): this;
        /**
            * Move the first Pt in this group to a specific position, and move all the other Pts correspondingly
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        moveTo(...args: any[]): this;
        /**
            * Scale this group's Pts from an anchor point. Default anchor point is the first Pt in this group.
            * @param scale scale ratio
            * @param anchor optional anchor point to scale from
            */
        scale(scale: number | number[] | PtLike, anchor?: PtLike): this;
        /**
            * Rotate this group's Pt from an anchor point in 2D. Default anchor point is the first Pt in this group.
            * @param angle rotate angle
            * @param anchor optional anchor point to scale from
            * @param axis optional string such as "yz" to specify a 2D plane
            */
        rotate2D(angle: number, anchor?: PtLike, axis?: string): this;
        /**
            * Shear this group's Pt from an anchor point in 2D. Default anchor point is the first Pt in this group.
            * @param shear shearing value which can be a number or an array of 2 numbers
            * @param anchor optional anchor point to scale from
            * @param axis optional string such as "yz" to specify a 2D plane
            */
        shear2D(scale: number | number[] | PtLike, anchor?: PtLike, axis?: string): this;
        /**
            * Reflect this group's Pts along a 2D line. Default anchor point is the first Pt in this group.
            * @param line a Group of 2 Pts that defines a line for reflection
            * @param axis optional axis such as "yz" to define a 2D plane of reflection
            */
        reflect2D(line: GroupLike, axis?: string): this;
        /**
            * Sort this group's Pts by values in a specific dimension
            * @param dim dimensional index
            * @param desc if true, sort descending. Default is false (ascending)
            */
        sortByDimension(dim: number, desc?: boolean): this;
        /**
            * Update each Pt in this Group with a Pt function
            * @param ptFn string name of an existing Pt function. Note that the function must return Pt.
            * @param args arguments for the function specified in ptFn
            */
        forEachPt(ptFn: string, ...args: any[]): this;
        /**
            * Add scalar or vector values to this group's Pts.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        add(...args: any[]): this;
        /**
            * Subtract scalar or vector values from this group's Pts.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        subtract(...args: any[]): this;
        /**
            * Multiply scalar or vector values (as element-wise) with this group's Pts.
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        multiply(...args: any[]): this;
        /**
            * Divide this group's Pts over scalar or vector values (as element-wise)
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        divide(...args: any[]): this;
        /**
            * Apply this group as a matrix and calculate matrix addition
            * @param g a scalar number, an array of numeric arrays, or a group of Pt
            * @returns a new Group
            */
        $matrixAdd(g: GroupLike | number[][] | number): Group;
        /**
            * Apply this group as a matrix and calculate matrix multiplication
            * @param g a scalar number, an array of numeric arrays, or a Group of K Pts, each with N dimensions (K-rows, N-columns) -- or if transposed is true, then N Pts with K dimensions
            * @param transposed (Only applicable if it's not elementwise multiplication) If true, then a and b's columns should match (ie, each Pt should have the same dimensions). Default is `false`.
            * @param elementwise if true, then the multiplication is done element-wise. Default is `false`.
            * @returns If not elementwise, this will return a new  Group with M Pt, each with N dimensions (M-rows, N-columns).
            */
        $matrixMultiply(g: GroupLike | number, transposed?: boolean, elementwise?: boolean): Group;
        /**
            * Zip one slice of an array of Pt. Imagine the Pts are organized in rows, then this function will take the values in a specific column.
            * @param idx index to zip at
            * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.
            */
        zipSlice(index: number, defaultValue?: number | boolean): Pt;
        /**
            * Zip a group of Pt. eg, [[1,2],[3,4],[5,6]] => [[1,3,5],[2,4,6]]
            * @param defaultValue a default value to fill if index out of bound. If not provided, it will throw an error instead.
            * @param useLongest If true, find the longest list of values in a Pt and use its length for zipping. Default is false, which uses the first item's length for zipping.
            */
        $zip(defaultValue?: number | boolean, useLongest?: boolean): Group;
        /**
            * Get a string representation of this group
            */
        toString(): string;
}

declare type AnimateFunction = (time?: number, frameTime?: number, currentSpace?: any) => void;
/**
 * Interface of a "player" object that can be added into a Space
 */
declare interface IPlayer {
        animateID?: string;
        animate?: AnimateFunction;
        resize?(size: IPt, evt?: Event): undefined;
        action?(type: string, px: number, py: number, evt: Event): any;
        start?(bound: Bound, space: Space): any;
}
declare interface ISpacePlayers {
        [key: string]: IPlayer;
}
declare interface ITimer {
        prev: number;
        diff: number;
        end: number;
}
/**
 * Space is an abstract class that represents a general context for expressing Pts.
 * See [Space guide](../../guide/Space-0500.html) for details.
 */
declare abstract class Space {
        id: string;
        protected bound: Bound;
        protected _time: ITimer;
        protected players: ISpacePlayers;
        protected playerCount: number;
        protected _ctx: any;
        protected _pointer: Pt;
        protected _isReady: boolean;
        protected _playing: boolean;
        /**
         * Set whether the rendering should be repainted on each frame
         * @param b a boolean value to set whether to repaint each frame
         */
        refresh(b: boolean): this;
        /**
         * Add an IPlayer to this space. An IPlayer can define the following callback functions:
         * - `animate( time, ftime, space )`
         * - `start(bound, space)`
         * - `resize( size, event )`
         * - `action( type, x, y, event )`
         * Subclasses of Space may define other callback functions.
         * @param player an IPlayer object with animate function, or simply a function(time, ftime){}
         */
        add(p: IPlayer | AnimateFunction): this;
        /**
         * Remove a player from this Space
         * @param player an IPlayer that has an `animateID` property
         */
        remove(player: IPlayer): this;
        /**
         * Remove all players from this Space
         */
        removeAll(): this;
        /**
         * Main play loop. This implements window.requestAnimationFrame and calls it recursively.
         * Override this `play()` function to implemenet your own animation loop.
         * @param time current time
         */
        play(time?: number): this;
        /**
         * Replay the animation after `stop()`. This resets the end-time counter.
         * You may also use `pause()` and `resume()` for temporary pause.
         */
        replay(): void;
        /**
         * Main animate function. This calls all the items to perform
         * @param time current time
         */
        protected playItems(time: number): void;
        /**
         * Pause the animation
         * @param toggle a boolean value to set if this function call should be a toggle (between pause and resume)
         */
        pause(toggle?: boolean): this;
        /**
         * Resume the pause animation
         */
        resume(): this;
        /**
         * Specify when the animation should stop: immediately, after a time period, or never stops.
         * @param t a value in millisecond to specify a time period to play before stopping, or `-1` to play forever, or `0` to end immediately. Default is 0 which will stop the animation immediately.
         */
        stop(t?: number): this;
        /**
         * Play animation loop, and then stop after `duration` time has passed.
         * @param duration a value in millisecond to specify a time period to play before stopping, or `-1` to play forever
         */
        playOnce(duration?: number): this;
        /**
         * Custom rendering
         * @param context rendering context
         */
        protected render(context: any): this;
        /**
         * Set a custom rendering `function(graphics_context, canvas_space)` if needed
         */
        customRendering: (context: any, self: Space) => null;
        /**
            * Get a boolean to indicate whether the animation is playing
            */
        readonly isPlaying: boolean;
        /**
         * Get this space's bounding box
         */
        readonly outerBound: Bound;
        /**
         * The bounding box of the canvas
         */
        readonly innerBound: Bound;
        /**
         * Get the size of this bounding box as a Pt
         */
        readonly size: Pt;
        /**
         * Get the size of this bounding box as a Pt
         */
        readonly center: Pt;
        /**
         * Get width of canvas
         */
        readonly width: number;
        /**
         * Get height of canvas
         */
        readonly height: number;
        /**
         * Resize the space
         * @param w `width or an IPt object
         * @param h height
         */
        abstract resize(b: IPt, evt?: Event): this;
        /**
         * clear all contents in the space
         */
        abstract clear(): this;
        /**
         * Get a default form for drawing in this space
         */
        abstract getForm(): Form;
}
declare type TouchPointsKey = "touches" | "changedTouches" | "targetTouches";
declare interface MultiTouchElement {
        addEventListener(evt: any, callback: Function): any;
        removeEventListener(evt: any, callback: Function): any;
}
declare abstract class MultiTouchSpace extends Space {
        protected _pressed: boolean;
        protected _dragged: boolean;
        protected _hasMouse: boolean;
        protected _hasTouch: boolean;
        protected _canvas: EventTarget;
        /**
         * Get the mouse or touch pointer that stores the last action
         */
        readonly pointer: Pt;
        /**
         * Bind event listener in canvas element. You can also use `bindMouse` or `bindTouch` to bind mouse or touch events conveniently.
         * @param evt an event string such as "mousedown"
         * @param callback callback function for this event
         */
        bindCanvas(evt: string, callback: EventListener): void;
        /**
         * Unbind a callback from the event listener
         * @param evt an event string such as "mousedown"
         * @param callback callback function to unbind
         */
        unbindCanvas(evt: string, callback: EventListener): void;
        /**
         * A convenient method to bind (or unbind) all mouse events in canvas element. All "players" added to this space that implements an `action` callback property will receive mouse event callbacks. The types of mouse actions are: "up", "down", "move", "drag", "drop", "over", and "out". See `Space`'s `add()` function fore more.
         * @param _bind a boolean value to bind mouse events if set to `true`. If `false`, all mouse events will be unbound. Default is true.
         * @see Space`'s [`add`](./_space_.space.html#add) function
         */
        bindMouse(_bind?: boolean): this;
        /**
         * A convenient method to bind (or unbind) all touch events in canvas element. All "players" added to this space that implements an `action` callback property will receive mouse event callbacks. The types of mouse actions are: "up", "down", "move", "drag", "drop", "over", and "out".
         * @param _bind a boolean value to bind touch events if set to `true`. If `false`, all mouse events will be unbound. Default is true.
         * @see Space`'s [`add`](./_space_.space.html#add) function
         */
        bindTouch(_bind?: boolean): this;
        /**
         * A convenient method to convert the touch points in a touch event to an array of `Pt`.
         * @param evt a touch event which contains touches, changedTouches, and targetTouches list
         * @param which a string to select a touches list: "touches", "changedTouches", or "targetTouches". Default is "touches"
         * @return an array of Pt, whose origin position (0,0) is offset to the top-left of this space
         */
        touchesToPoints(evt: TouchEvent, which?: TouchPointsKey): Pt[];
        /**
         * Go through all the `players` and call its `action` callback function
         * @param type "up", "down", "move", "drag", "drop", "over", and "out"
         * @param evt mouse or touch event
         */
        protected _mouseAction(type: string, evt: MouseEvent | TouchEvent): void;
        /**
         * MouseDown handler
         * @param evt
         */
        protected _mouseDown(evt: MouseEvent | TouchEvent): boolean;
        /**
         * MouseUp handler
         * @param evt
         */
        protected _mouseUp(evt: MouseEvent | TouchEvent): boolean;
        /**
         * MouseMove handler
         * @param evt
         */
        protected _mouseMove(evt: MouseEvent | TouchEvent): boolean;
        /**
         * MouseOver handler
         * @param evt
         */
        protected _mouseOver(evt: MouseEvent | TouchEvent): boolean;
        /**
         * MouseOut handler
         * @param evt
         */
        protected _mouseOut(evt: MouseEvent | TouchEvent): boolean;
        /**
         * TouchMove handler
         * @param evt
         */
        protected _touchMove(evt: TouchEvent): boolean;
}

/**
    * A Space for SVG elements
    */
declare class SVGSpace extends DOMSpace {
        id: string;
        protected _bgcolor: string;
        /**
         * Create a SVGSpace which represents a Space for SVG elements
         * @param elem Specify an element by its "id" attribute as string, or by the element object itself. An element can be an existing `<svg>`, or a `<div>` container in which a new `<svg>` will be created. If left empty, a `<div id="pt_container"><svg id="pt" /></div>` will be added to DOM. Use css to customize its appearance if needed.
         * @param callback an optional callback `function(boundingBox, spaceElement)` to be called when canvas is appended and ready. Alternatively, a "ready" event will also be fired from the `<svg>` element when it's appended, which can be traced with `spaceInstance.canvas.addEventListener("ready")`
         * @example `new SVGSpace( "#myElementID" )`
         */
        constructor(elem: string | Element, callback?: Function);
        /**
         * Get a new `SVGForm` for drawing
         * @see `SVGForm`
         */
        getForm(): SVGForm;
        /**
         * Get the html element
         */
        readonly element: Element;
        /**
         * This overrides Space's `resize` function. It's used as a callback function for window's resize event and not usually called directly. You can keep track of resize events with `resize: (bound ,evt)` callback in your player objects (See `Space`'s `add()` function).
         * @param b a Bound object to resize to
         * @param evt Optionally pass a resize event
         */
        resize(b: Bound, evt?: Event): this;
        /**
            * A static function to add a svg element inside a node. Usually you don't need to use this directly. See methods in `SVGForm` instead.
            * @param parent the parent element, or `null` to use current `<svg>` as parent.
            * @param name a string of element name,  such as `rect` or `circle`
            * @param id id attribute of the new element
            */
        static svgElement(parent: Element, name: string, id?: string): SVGElement;
        /**
         * Remove an item from this Space
         * @param item a player item with an auto-assigned `animateID` property
         */
        remove(player: IPlayer): this;
        /**
            * Remove all items from this Space
            */
        removeAll(): this;
}
/**
 * SVGForm is an implementation of abstract class VisualForm. It provide methods to express Pts on SVGSpace.
 * You may extend SVGForm to implement your own expressions for SVGSpace.
 */
declare class SVGForm extends VisualForm {
        protected _ctx: DOMFormContext;
        static groupID: number;
        static domID: number;
        protected _space: SVGSpace;
        protected _ready: boolean;
        /**
         * Create a new SVGForm. You may also use `space.getForm()` to get the default form.
         * @param space an instance of SVGSpace
         */
        constructor(space: SVGSpace);
        /**
         * get the SVGSpace instance that this form is associated with
         */
        readonly space: SVGSpace;
        /**
            * Update a style in _ctx context or throw an Erorr if the style doesn't exist
            * @param k style key
            * @param v  style value
            */
        protected styleTo(k: any, v: any): void;
        /**
             * Set current fill style. Provide a valid color string or `false` to specify no fill color.
             * @example `form.fill("#F90")`, `form.fill("rgba(0,0,0,.5")`, `form.fill(false)`
             * @param c fill color
             */
        fill(c: string | boolean): this;
        /**
             * Set current stroke style. Provide a valid color string or `false` to specify no stroke color.
             * @example `form.stroke("#F90")`, `form.stroke("rgba(0,0,0,.5")`, `form.stroke(false)`, `form.stroke("#000", 0.5, 'round', 'square')`
             * @param c stroke color which can be as color, gradient, or pattern. (See [canvas documentation](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle))
             * @param width Optional value (can be floating point) to set line width
             * @param linejoin Optional string to set line joint style. Can be "miter", "bevel", or "round".
             * @param linecap Optional string to set line cap style. Can be "butt", "round", or "square".
             */
        stroke(c: string | boolean, width?: number, linejoin?: string, linecap?: string): this;
        /**
            * Add custom class to the created element
            * @param c custom class name or `false` to reset it
            * @example `form.fill("#f00").cls("myClass").rects(r)` `form.cls(false).circles(c)`
            */
        cls(c: string | boolean): this;
        /**
         * Set the current font
         * @param sizeOrFont either a number to specify font-size, or a `Font` object to specify all font properties
         * @param weight Optional font-weight string such as "bold"
         * @param style Optional font-style string such as "italic"
         * @param lineHeight Optional line-height number suchas 1.5
         * @param family Optional font-family such as "Helvetica, sans-serif"
         * @example `form.font( myFont )`, `form.font(14, "bold")`
         */
        font(sizeOrFont: number | Font, weight?: string, style?: string, lineHeight?: number, family?: string): this;
        /**
         * Reset the context's common styles to this form's styles. This supports using multiple forms on the same canvas context.
         */
        reset(): this;
        /**
            * Set this form's group scope by an ID, and optionally define the group's parent element. A group scope keeps track of elements by their generated IDs, and updates their properties as needed. See also `scope()`.
            * @param group_id a string to use as prefix for the group's id. For example, group_id "hello" will create elements with id like "hello-1", "hello-2", etc
            * @param group Optional DOM or SVG element to define this group's parent element
            * @returns this form's context
            */
        updateScope(group_id: string, group?: Element): object;
        /**
            * Set the current group scope to an item added into space, in order to keep track of any point, circle, etc created within it. The item must have an `animateID` property, so that elements created within the item will have generated IDs like "item-{animateID}-{count}".
            * @param item a "player" item that's added to space (see `space.add(...)`) and has an `animateID` property
            * @returns this form's context
            */
        scope(item: IPlayer): object;
        /**
            * Get next available id in the current group
            * @returns an id string
            */
        nextID(): string;
        /**
            * A static function to generate an ID string based on a context object
            * @param ctx a context object for an SVGForm
            */
        static getID(ctx: any): string;
        /**
            * A static function to generate an ID string for a scope, based on a "player" item in the Space
            * @param item a "player" item that's added to space (see `space.add(...)`) and has an `animateID` property
            */
        static scopeID(item: IPlayer): string;
        /**
            * A static function to help adding style object to an element. This put all styles into `style` attribute instead of individual attributes, so that the styles can be parsed by Adobe Illustrator.
            * @param elem A DOM element to add to
            * @param styles an object of style properties
            * @example `SVGForm.style(elem, {fill: "#f90", stroke: false})`
            * @returns this DOM element
            */
        static style(elem: SVGElement, styles: object): Element;
        /**
             * Draws a point
             * @param ctx a context object of SVGForm
             * @param pt a Pt object or numeric array
             * @param radius radius of the point. Default is 5.
             * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
             * @example `SVGForm.point( p )`, `SVGForm.point( p, 10, "circle" )`
             */
        static point(ctx: DOMFormContext, pt: PtLike, radius?: number, shape?: string): SVGElement;
        /**
             * Draws a point
             * @param p a Pt object
             * @param radius radius of the point. Default is 5.
             * @param shape The shape of the point. Defaults to "square", but it can be "circle" or a custom shape function in your own implementation.
             * @example `form.point( p )`, `form.point( p, 10, "circle" )`
             */
        point(pt: PtLike, radius?: number, shape?: string): this;
        /**
             * A static function to draw a circle
             * @param ctx a context object of SVGForm
             * @param pt center position of the circle
             * @param radius radius of the circle
             */
        static circle(ctx: DOMFormContext, pt: PtLike, radius?: number): SVGElement;
        /**
             * Draw a circle
             * @param pts usually a Group of 2 Pts, but it can also take an array of two numeric arrays [ [position], [size] ]
             * @see [`Circle.fromCenter`](./_op_.circle.html#frompt)
             */
        circle(pts: GroupLike | number[][]): this;
        /**
             * A static function to draw an arc.
             * @param ctx a context object of SVGForm
             * @param pt center position
             * @param radius radius of the arc circle
             * @param startAngle start angle of the arc
             * @param endAngle end angle of the arc
             * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
             */
        static arc(ctx: DOMFormContext, pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): SVGElement;
        /**
             * Draw an arc.
             * @param pt center position
             * @param radius radius of the arc circle
             * @param startAngle start angle of the arc
             * @param endAngle end angle of the arc
             * @param cc an optional boolean value to specify if it should be drawn clockwise (`false`) or counter-clockwise (`true`). Default is clockwise.
             */
        arc(pt: PtLike, radius: number, startAngle: number, endAngle: number, cc?: boolean): this;
        /**
             * A static function to draw a square
             * @param ctx a context object of SVGForm
             * @param pt center position of the square
             * @param halfsize half size of the square
             */
        static square(ctx: DOMFormContext, pt: PtLike, halfsize: number): SVGElement;
        /**
            * Draw a square, given a center and its half-size
            * @param pt center Pt
            * @param halfsize half-size
            */
        square(pt: PtLike, halfsize: number): this;
        /**
         * A static function to draw a line
         * @param ctx a context object of SVGForm
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        static line(ctx: DOMFormContext, pts: GroupLike | number[][]): SVGElement;
        /**
         * Draw a line or polyline
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        line(pts: GroupLike | number[][]): this;
        /**
            * A static helper function to draw polyline or polygon
            * @param ctx a context object of SVGForm
            * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
            * @param closePath a boolean to specify if the polygon path should be closed
            */
        static _poly(ctx: DOMFormContext, pts: GroupLike | number[][], closePath?: boolean): SVGElement;
        /**
             * A static function to draw polygon
             * @param ctx a context object of SVGForm
             * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
             */
        static polygon(ctx: DOMFormContext, pts: GroupLike | number[][]): SVGElement;
        /**
         * Draw a polygon
         * @param pts a Group of multiple Pts, or an array of multiple numeric arrays
         */
        polygon(pts: GroupLike | number[][]): this;
        /**
         * A static function to draw a rectangle
         * @param ctx a context object of SVGForm
         * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
         */
        static rect(ctx: DOMFormContext, pts: GroupLike | number[][]): SVGElement;
        /**
             * Draw a rectangle
             * @param pts usually a Group of 2 Pts specifying the top-left and bottom-right positions. Alternatively it can be an array of numeric arrays.
             */
        rect(pts: number[][] | Pt[]): this;
        /**
             * A static function to draw text
             * @param ctx a context object of SVGForm
             * @param `pt` a Point object to specify the anchor point
             * @param `txt` a string of text to draw
             * @param `maxWidth` specify a maximum width per line
             */
        static text(ctx: DOMFormContext, pt: PtLike, txt: string): SVGElement;
        /**
             * Draw text on canvas
             * @param `pt` a Pt or numeric array to specify the anchor point
             * @param `txt` text
             * @param `maxWidth` specify a maximum width per line
             */
        text(pt: PtLike, txt: string): this;
        /**
             * A convenient way to draw some text on canvas for logging or debugging. It'll be draw on the top-left of the canvas as an overlay.
             * @param txt text
             */
        log(txt: any): this;
}

/**
    * Various constant values for enumerations and calculations
    */
declare const Const: {
        xy: string;
        yz: string;
        xz: string;
        xyz: string;
        horizontal: number;
        vertical: number;
        identical: number;
        right: number;
        bottom_right: number;
        bottom: number;
        bottom_left: number;
        left: number;
        top_left: number;
        top: number;
        top_right: number;
        epsilon: number;
        pi: number;
        two_pi: number;
        half_pi: number;
        quarter_pi: number;
        one_degree: number;
        rad_to_deg: number;
        deg_to_rad: number;
        gravity: number;
        newton: number;
        gaussian: number;
};
/**
    * Util provides various helper functions
    */
declare class Util {
        static warnLevel: "error" | "warn" | "default";
        /**
            * Convert different kinds of parameters (arguments, array, object) into an array of numbers
            * @param args a list of numbers, an array of number, or an object with {x,y,z,w} properties
            */
        static getArgs(args: any[]): Array<number>;
        /**
            * Send a warning message based on Util.warnLevel global setting. This allows you to dynamically set whether minor errors should be thrown or printed in console or muted.
            * @param message any error or warning message
            * @param defaultReturn optional return value
            */
        static warn(message?: string, defaultReturn?: any): any;
        static randomInt(range: number, start?: number): number;
        /**
            * Split an array into chunks of sub-array
            * @param pts an array
            * @param size chunk size, ie, number of items in a chunk
            * @param stride optional parameter to "walk through" the array in steps
            * @param loopBack if `true`, always go through the array till the end and loop back to the beginning to complete the segments if needed
            */
        static split(pts: any[], size: number, stride?: number, loopBack?: boolean): any[][];
        /**
            * Flatten an array of arrays such as Group[] to a flat Array or Group
            * @param pts an array, usually an array of Groups
            * @param flattenAsGroup a boolean to specify whether the return type should be a Group or Array. Default is `true` which returns a Group.
            */
        static flatten(pts: any[], flattenAsGroup?: boolean): any;
        /**
        * Given two arrays of object<T>, and a function that operate on two object<T>, return an array of T
        * @param a an array of object<T>, eg [ Group, Group, ... ]
        * @param b another array of object<T>
        * @param op a function that takes two parameters (a, b) and returns a T
        */
        static combine<T>(a: T[], b: T[], op: (a: T, b: T) => T): T[];
        /**
            * Zip arrays. eg, [[1,2],[3,4],[5,6]] => [[1,3,5],[2,4,6]]
            * @param arrays an array of arrays
            */
        static zip(...arrays: Array<any>[]): any[];
}

